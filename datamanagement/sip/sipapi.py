#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed May  8 16:55:16 2013 by generateDS.py version 2.8a.
#

import sys
import getopt
import re as re_
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%dT%H:%M:%S').replace(tzinfo = tz)
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Frequency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None, extensiontype_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_FrequencyUnit(self, value):
        # Validate type FrequencyUnit, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Frequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Frequency'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Frequency', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Frequency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
            self.validate_FrequencyUnit(self.units)    # validate type FrequencyUnit
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Frequency


class Length(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Length.subclass:
            return Length.subclass(*args_, **kwargs_)
        else:
            return Length(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_LengthUnit(self, value):
        # Validate type LengthUnit, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Length', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Length')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Length'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Length', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Length'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
            self.validate_LengthUnit(self.units)    # validate type LengthUnit
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Length


class Time(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Time.subclass:
            return Time.subclass(*args_, **kwargs_)
        else:
            return Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_TimeUnit(self, value):
        # Validate type TimeUnit, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Time', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Time')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Time'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Time', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Time'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
            self.validate_TimeUnit(self.units)    # validate type TimeUnit
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Time


class Angle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Angle.subclass:
            return Angle.subclass(*args_, **kwargs_)
        else:
            return Angle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_AngleUnit(self, value):
        # Validate type AngleUnit, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Angle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Angle')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Angle'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Angle', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Angle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
            self.validate_AngleUnit(self.units)    # validate type AngleUnit
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Angle


class Pixel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Pixel.subclass:
            return Pixel.subclass(*args_, **kwargs_)
        else:
            return Pixel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_PixelUnit(self, value):
        # Validate type PixelUnit, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Pixel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pixel')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Pixel'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Pixel', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Pixel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
            self.validate_PixelUnit(self.units)    # validate type PixelUnit
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Pixel


class ListOfFrequencies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequencies=None, unit=None):
        self.frequencies = frequencies
        self.unit = unit
    def factory(*args_, **kwargs_):
        if ListOfFrequencies.subclass:
            return ListOfFrequencies.subclass(*args_, **kwargs_)
        else:
            return ListOfFrequencies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencies(self): return self.frequencies
    def set_frequencies(self, frequencies): self.frequencies = frequencies
    def validate_ListOfDouble(self, value):
        # Validate type ListOfDouble, a restriction on xs:double.
        pass
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_FrequencyUnit(self, value):
        # Validate type FrequencyUnit, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ListOfFrequencies', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ListOfFrequencies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ListOfFrequencies'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ListOfFrequencies', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.frequencies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrequencies>%s</%sfrequencies>%s' % (namespace_, self.gds_format_double_list(self.frequencies, input_name='frequencies'), namespace_, eol_))
        if self.unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunit>%s</%sunit>%s' % (namespace_, self.gds_format_string(quote_xml(self.unit).encode(ExternalEncoding), input_name='unit'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.frequencies is not None or
            self.unit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ListOfFrequencies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.frequencies is not None:
            showIndent(outfile, level)
            outfile.write('frequencies=%e,\n' % self.frequencies)
        if self.unit is not None:
            showIndent(outfile, level)
            outfile.write('unit=%s,\n' % quote_python(self.unit).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frequencies':
            frequencies_ = child_.text
            frequencies_ = self.gds_validate_double_list(frequencies_, node, 'frequencies')
            self.frequencies = frequencies_
            self.frequencies = self.frequencies.split()
            self.validate_ListOfDouble(self.frequencies)    # validate type ListOfDouble
        elif nodeName_ == 'unit':
            unit_ = child_.text
            unit_ = self.gds_validate_string(unit_, node, 'unit')
            self.unit = unit_
            self.validate_FrequencyUnit(self.unit)    # validate type FrequencyUnit
# end class ListOfFrequencies


class IdentifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, identifier=None, name=None):
        self.source = source
        self.identifier = identifier
        self.name = name
    def factory(*args_, **kwargs_):
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='IdentifierType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_format_string(quote_xml(self.source).encode(ExternalEncoding), input_name='source'), namespace_, eol_))
        if self.identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.identifier).encode(ExternalEncoding), input_name='identifier'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.source is not None or
            self.identifier is not None or
            self.name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdentifierType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % quote_python(self.source).encode(ExternalEncoding))
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=%s,\n' % quote_python(self.identifier).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
        elif nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class IdentifierType


class Pointing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rightAscension=None, azimuth=None, declination=None, altitude=None, equinox=None):
        self.rightAscension = rightAscension
        self.azimuth = azimuth
        self.declination = declination
        self.altitude = altitude
        self.equinox = equinox
    def factory(*args_, **kwargs_):
        if Pointing.subclass:
            return Pointing.subclass(*args_, **kwargs_)
        else:
            return Pointing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rightAscension(self): return self.rightAscension
    def set_rightAscension(self, rightAscension): self.rightAscension = rightAscension
    def get_azimuth(self): return self.azimuth
    def set_azimuth(self, azimuth): self.azimuth = azimuth
    def get_declination(self): return self.declination
    def set_declination(self, declination): self.declination = declination
    def get_altitude(self): return self.altitude
    def set_altitude(self, altitude): self.altitude = altitude
    def get_equinox(self): return self.equinox
    def set_equinox(self, equinox): self.equinox = equinox
    def validate_EquinoxType(self, value):
        # Validate type EquinoxType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Pointing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pointing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Pointing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Pointing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rightAscension is not None:
            self.rightAscension.export(outfile, level, namespace_, name_='rightAscension', pretty_print=pretty_print)
        if self.azimuth is not None:
            self.azimuth.export(outfile, level, namespace_, name_='azimuth', pretty_print=pretty_print)
        if self.declination is not None:
            self.declination.export(outfile, level, namespace_, name_='declination', pretty_print=pretty_print)
        if self.altitude is not None:
            self.altitude.export(outfile, level, namespace_, name_='altitude', pretty_print=pretty_print)
        if self.equinox is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequinox>%s</%sequinox>%s' % (namespace_, self.gds_format_string(quote_xml(self.equinox).encode(ExternalEncoding), input_name='equinox'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.rightAscension is not None or
            self.azimuth is not None or
            self.declination is not None or
            self.altitude is not None or
            self.equinox is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Pointing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rightAscension is not None:
            showIndent(outfile, level)
            outfile.write('rightAscension=model_.Angle(\n')
            self.rightAscension.exportLiteral(outfile, level, name_='rightAscension')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.azimuth is not None:
            showIndent(outfile, level)
            outfile.write('azimuth=model_.Angle(\n')
            self.azimuth.exportLiteral(outfile, level, name_='azimuth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.declination is not None:
            showIndent(outfile, level)
            outfile.write('declination=model_.Angle(\n')
            self.declination.exportLiteral(outfile, level, name_='declination')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.altitude is not None:
            showIndent(outfile, level)
            outfile.write('altitude=model_.Angle(\n')
            self.altitude.exportLiteral(outfile, level, name_='altitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.equinox is not None:
            showIndent(outfile, level)
            outfile.write('equinox=%s,\n' % quote_python(self.equinox).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rightAscension':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_rightAscension(obj_)
        elif nodeName_ == 'azimuth':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_azimuth(obj_)
        elif nodeName_ == 'declination':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_declination(obj_)
        elif nodeName_ == 'altitude':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_altitude(obj_)
        elif nodeName_ == 'equinox':
            equinox_ = child_.text
            equinox_ = self.gds_validate_string(equinox_, node, 'equinox')
            self.equinox = equinox_
            self.validate_EquinoxType(self.equinox)    # validate type EquinoxType
# end class Pointing


class Coordinates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coordinateSystem=None, x=None, y=None, z=None, radius=None, longitude=None, latitude=None):
        self.coordinateSystem = coordinateSystem
        self.x = x
        self.y = y
        self.z = z
        self.radius = radius
        self.longitude = longitude
        self.latitude = latitude
    def factory(*args_, **kwargs_):
        if Coordinates.subclass:
            return Coordinates.subclass(*args_, **kwargs_)
        else:
            return Coordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coordinateSystem(self): return self.coordinateSystem
    def set_coordinateSystem(self, coordinateSystem): self.coordinateSystem = coordinateSystem
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def export(self, outfile, level, namespace_='', name_='Coordinates', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Coordinates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Coordinates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Coordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coordinateSystem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoordinateSystem>%s</%scoordinateSystem>%s' % (namespace_, self.gds_format_string(quote_xml(self.coordinateSystem).encode(ExternalEncoding), input_name='coordinateSystem'), namespace_, eol_))
        if self.x is not None:
            self.x.export(outfile, level, namespace_, name_='x', pretty_print=pretty_print)
        if self.y is not None:
            self.y.export(outfile, level, namespace_, name_='y', pretty_print=pretty_print)
        if self.z is not None:
            self.z.export(outfile, level, namespace_, name_='z', pretty_print=pretty_print)
        if self.radius is not None:
            self.radius.export(outfile, level, namespace_, name_='radius', pretty_print=pretty_print)
        if self.longitude is not None:
            self.longitude.export(outfile, level, namespace_, name_='longitude', pretty_print=pretty_print)
        if self.latitude is not None:
            self.latitude.export(outfile, level, namespace_, name_='latitude', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.coordinateSystem is not None or
            self.x is not None or
            self.y is not None or
            self.z is not None or
            self.radius is not None or
            self.longitude is not None or
            self.latitude is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Coordinates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.coordinateSystem is not None:
            showIndent(outfile, level)
            outfile.write('coordinateSystem=%s,\n' % quote_python(self.coordinateSystem).encode(ExternalEncoding))
        if self.x is not None:
            showIndent(outfile, level)
            outfile.write('x=model_.Length(\n')
            self.x.exportLiteral(outfile, level, name_='x')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.y is not None:
            showIndent(outfile, level)
            outfile.write('y=model_.Length(\n')
            self.y.exportLiteral(outfile, level, name_='y')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.z is not None:
            showIndent(outfile, level)
            outfile.write('z=model_.Length(\n')
            self.z.exportLiteral(outfile, level, name_='z')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.radius is not None:
            showIndent(outfile, level)
            outfile.write('radius=model_.Length(\n')
            self.radius.exportLiteral(outfile, level, name_='radius')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.longitude is not None:
            showIndent(outfile, level)
            outfile.write('longitude=model_.Angle(\n')
            self.longitude.exportLiteral(outfile, level, name_='longitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.latitude is not None:
            showIndent(outfile, level)
            outfile.write('latitude=model_.Angle(\n')
            self.latitude.exportLiteral(outfile, level, name_='latitude')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coordinateSystem':
            coordinateSystem_ = child_.text
            coordinateSystem_ = self.gds_validate_string(coordinateSystem_, node, 'coordinateSystem')
            self.coordinateSystem = coordinateSystem_
        elif nodeName_ == 'x':
            obj_ = Length.factory()
            obj_.build(child_)
            self.set_x(obj_)
        elif nodeName_ == 'y':
            obj_ = Length.factory()
            obj_.build(child_)
            self.set_y(obj_)
        elif nodeName_ == 'z':
            obj_ = Length.factory()
            obj_.build(child_)
            self.set_z(obj_)
        elif nodeName_ == 'radius':
            obj_ = Length.factory()
            obj_.build(child_)
            self.set_radius(obj_)
        elif nodeName_ == 'longitude':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_longitude(obj_)
        elif nodeName_ == 'latitude':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_latitude(obj_)
# end class Coordinates


class coordinateSystem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if coordinateSystem.subclass:
            return coordinateSystem.subclass(*args_, **kwargs_)
        else:
            return coordinateSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='coordinateSystem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinateSystem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='coordinateSystem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='coordinateSystem', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='coordinateSystem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class coordinateSystem


class AntennaField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, location=None):
        self.name = name
        self.location = location
    def factory(*args_, **kwargs_):
        if AntennaField.subclass:
            return AntennaField.subclass(*args_, **kwargs_)
        else:
            return AntennaField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_AntennaFieldType(self, value):
        # Validate type AntennaFieldType, a restriction on xs:string.
        pass
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def export(self, outfile, level, namespace_='', name_='AntennaField', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AntennaField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AntennaField'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AntennaField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AntennaField'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.Coordinates(\n')
            self.location.exportLiteral(outfile, level, name_='location')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            self.validate_AntennaFieldType(self.name)    # validate type AntennaFieldType
        elif nodeName_ == 'location':
            obj_ = Coordinates.factory()
            obj_.build(child_)
            self.set_location(obj_)
# end class AntennaField


class Stations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, station=None):
        if station is None:
            self.station = []
        else:
            self.station = station
    def factory(*args_, **kwargs_):
        if Stations.subclass:
            return Stations.subclass(*args_, **kwargs_)
        else:
            return Stations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def add_station(self, value): self.station.append(value)
    def insert_station(self, index, value): self.station[index] = value
    def export(self, outfile, level, namespace_='', name_='Stations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Stations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Stations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for station_ in self.station:
            station_.export(outfile, level, namespace_, name_='station', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.station
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Stations'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('station=[\n')
        level += 1
        for station_ in self.station:
            showIndent(outfile, level)
            outfile.write('model_.Station(\n')
            station_.exportLiteral(outfile, level, name_='Station')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'station':
            obj_ = Station.factory()
            obj_.build(child_)
            self.station.append(obj_)
# end class Stations


class Station(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, stationType=None, antennaField=None):
        self.name = name
        self.stationType = stationType
        if antennaField is None:
            self.antennaField = []
        else:
            self.antennaField = antennaField
    def factory(*args_, **kwargs_):
        if Station.subclass:
            return Station.subclass(*args_, **kwargs_)
        else:
            return Station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_stationType(self): return self.stationType
    def set_stationType(self, stationType): self.stationType = stationType
    def validate_StationTypeType(self, value):
        # Validate type StationTypeType, a restriction on xs:string.
        pass
    def get_antennaField(self): return self.antennaField
    def set_antennaField(self, antennaField): self.antennaField = antennaField
    def add_antennaField(self, value): self.antennaField.append(value)
    def insert_antennaField(self, index, value): self.antennaField[index] = value
    def export(self, outfile, level, namespace_='', name_='Station', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Station')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Station'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Station', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.stationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstationType>%s</%sstationType>%s' % (namespace_, self.gds_format_string(quote_xml(self.stationType).encode(ExternalEncoding), input_name='stationType'), namespace_, eol_))
        for antennaField_ in self.antennaField:
            antennaField_.export(outfile, level, namespace_, name_='antennaField', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.stationType is not None or
            self.antennaField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Station'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.stationType is not None:
            showIndent(outfile, level)
            outfile.write('stationType=%s,\n' % quote_python(self.stationType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('antennaField=[\n')
        level += 1
        for antennaField_ in self.antennaField:
            showIndent(outfile, level)
            outfile.write('model_.AntennaField(\n')
            antennaField_.exportLiteral(outfile, level, name_='AntennaField')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'stationType':
            stationType_ = child_.text
            stationType_ = self.gds_validate_string(stationType_, node, 'stationType')
            self.stationType = stationType_
            self.validate_StationTypeType(self.stationType)    # validate type StationTypeType
        elif nodeName_ == 'antennaField':
            obj_ = AntennaField.factory()
            obj_.build(child_)
            self.antennaField.append(obj_)
# end class Station


class Process(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, extensiontype_=None):
        self.processIdentifier = processIdentifier
        self.observationId = observationId
        self.parset = parset
        self.strategyName = strategyName
        self.strategyDescription = strategyDescription
        self.startTime = startTime
        self.duration = duration
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Process.subclass:
            return Process.subclass(*args_, **kwargs_)
        else:
            return Process(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processIdentifier(self): return self.processIdentifier
    def set_processIdentifier(self, processIdentifier): self.processIdentifier = processIdentifier
    def get_observationId(self): return self.observationId
    def set_observationId(self, observationId): self.observationId = observationId
    def get_parset(self): return self.parset
    def set_parset(self, parset): self.parset = parset
    def get_strategyName(self): return self.strategyName
    def set_strategyName(self, strategyName): self.strategyName = strategyName
    def get_strategyDescription(self): return self.strategyDescription
    def set_strategyDescription(self, strategyDescription): self.strategyDescription = strategyDescription
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Process', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Process')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Process'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Process', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processIdentifier is not None:
            self.processIdentifier.export(outfile, level, namespace_, name_='processIdentifier', pretty_print=pretty_print)
        if self.observationId is not None:
            self.observationId.export(outfile, level, namespace_, name_='observationId', pretty_print=pretty_print)
        if self.parset is not None:
            self.parset.export(outfile, level, namespace_, name_='parset', pretty_print=pretty_print)
        if self.strategyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrategyName>%s</%sstrategyName>%s' % (namespace_, self.gds_format_string(quote_xml(self.strategyName).encode(ExternalEncoding), input_name='strategyName'), namespace_, eol_))
        if self.strategyDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstrategyDescription>%s</%sstrategyDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.strategyDescription).encode(ExternalEncoding), input_name='strategyDescription'), namespace_, eol_))
        if self.startTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartTime>%s</%sstartTime>%s' % (namespace_, self.gds_format_datetime(self.startTime, input_name='startTime'), namespace_, eol_))
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespace_, self.gds_format_string(quote_xml(self.duration).encode(ExternalEncoding), input_name='duration'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.processIdentifier is not None or
            self.observationId is not None or
            self.parset is not None or
            self.strategyName is not None or
            self.strategyDescription is not None or
            self.startTime is not None or
            self.duration is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Process'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('processIdentifier=model_.IdentifierType(\n')
            self.processIdentifier.exportLiteral(outfile, level, name_='processIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.observationId is not None:
            showIndent(outfile, level)
            outfile.write('observationId=model_.IdentifierType(\n')
            self.observationId.exportLiteral(outfile, level, name_='observationId')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parset is not None:
            showIndent(outfile, level)
            outfile.write('parset=model_.IdentifierType(\n')
            self.parset.exportLiteral(outfile, level, name_='parset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.strategyName is not None:
            showIndent(outfile, level)
            outfile.write('strategyName=%s,\n' % quote_python(self.strategyName).encode(ExternalEncoding))
        if self.strategyDescription is not None:
            showIndent(outfile, level)
            outfile.write('strategyDescription=%s,\n' % quote_python(self.strategyDescription).encode(ExternalEncoding))
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=%s,\n' % quote_python(self.duration).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_processIdentifier(obj_)
        elif nodeName_ == 'observationId':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_observationId(obj_)
        elif nodeName_ == 'parset':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_parset(obj_)
        elif nodeName_ == 'strategyName':
            strategyName_ = child_.text
            strategyName_ = self.gds_validate_string(strategyName_, node, 'strategyName')
            self.strategyName = strategyName_
        elif nodeName_ == 'strategyDescription':
            strategyDescription_ = child_.text
            strategyDescription_ = self.gds_validate_string(strategyDescription_, node, 'strategyDescription')
            self.strategyDescription = strategyDescription_
        elif nodeName_ == 'startTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'startTime')
            self.startTime = dval_
        elif nodeName_ == 'duration':
            duration_ = child_.text
            duration_ = self.gds_validate_string(duration_, node, 'duration')
            self.duration = duration_
# end class Process


class ClockType(Frequency):
    subclass = None
    superclass = Frequency
    def __init__(self, units=None, valueOf_=None):
        super(ClockType, self).__init__(units, valueOf_, )
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ClockType.subclass:
            return ClockType.subclass(*args_, **kwargs_)
        else:
            return ClockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_FrequencyUnit(self, value):
        # Validate type FrequencyUnit, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ClockType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClockType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClockType'):
        super(ClockType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ClockType')
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClockType', fromsubclass_=False, pretty_print=True):
        super(ClockType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ClockType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClockType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
        super(ClockType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ClockType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
            self.validate_FrequencyUnit(self.units)    # validate type FrequencyUnit
        super(ClockType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClockType


class Observation(Process):
    subclass = None
    superclass = Process
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, observingMode=None, observationDescription=None, instrumentFilter=None, clock=None, stationSelection=None, antennaSet=None, timeSystem=None, channelWidth=None, channelsPerSubband=None, numberOfStations=None, stations=None, numberOfSubArrayPointings=None, subArrayPointings=None, numberOftransientBufferBoardEvents=None, transientBufferBoardEvents=None, numberOfCorrelatedDataProducts=None, numberOfBeamFormedDataProducts=None, numberOfBitsPerSample=None):
        super(Observation, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, )
        self.observingMode = observingMode
        self.observationDescription = observationDescription
        self.instrumentFilter = instrumentFilter
        self.clock = clock
        self.stationSelection = stationSelection
        self.antennaSet = antennaSet
        self.timeSystem = timeSystem
        self.channelWidth = channelWidth
        self.channelsPerSubband = channelsPerSubband
        self.numberOfStations = numberOfStations
        self.stations = stations
        self.numberOfSubArrayPointings = numberOfSubArrayPointings
        self.subArrayPointings = subArrayPointings
        self.numberOftransientBufferBoardEvents = numberOftransientBufferBoardEvents
        self.transientBufferBoardEvents = transientBufferBoardEvents
        self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
        self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
        self.numberOfBitsPerSample = numberOfBitsPerSample
    def factory(*args_, **kwargs_):
        if Observation.subclass:
            return Observation.subclass(*args_, **kwargs_)
        else:
            return Observation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_observingMode(self): return self.observingMode
    def set_observingMode(self, observingMode): self.observingMode = observingMode
    def validate_ObservingModeType(self, value):
        # Validate type ObservingModeType, a restriction on xs:string.
        pass
    def get_observationDescription(self): return self.observationDescription
    def set_observationDescription(self, observationDescription): self.observationDescription = observationDescription
    def get_instrumentFilter(self): return self.instrumentFilter
    def set_instrumentFilter(self, instrumentFilter): self.instrumentFilter = instrumentFilter
    def validate_FilterSelectionType(self, value):
        # Validate type FilterSelectionType, a restriction on xs:string.
        pass
    def get_clock(self): return self.clock
    def set_clock(self, clock): self.clock = clock
    def get_stationSelection(self): return self.stationSelection
    def set_stationSelection(self, stationSelection): self.stationSelection = stationSelection
    def validate_StationSelectionType(self, value):
        # Validate type StationSelectionType, a restriction on xs:string.
        pass
    def get_antennaSet(self): return self.antennaSet
    def set_antennaSet(self, antennaSet): self.antennaSet = antennaSet
    def validate_AntennaSetType(self, value):
        # Validate type AntennaSetType, a restriction on xs:string.
        pass
    def get_timeSystem(self): return self.timeSystem
    def set_timeSystem(self, timeSystem): self.timeSystem = timeSystem
    def validate_TimeSystemType(self, value):
        # Validate type TimeSystemType, a restriction on xs:string.
        pass
    def get_channelWidth(self): return self.channelWidth
    def set_channelWidth(self, channelWidth): self.channelWidth = channelWidth
    def get_channelsPerSubband(self): return self.channelsPerSubband
    def set_channelsPerSubband(self, channelsPerSubband): self.channelsPerSubband = channelsPerSubband
    def get_numberOfStations(self): return self.numberOfStations
    def set_numberOfStations(self, numberOfStations): self.numberOfStations = numberOfStations
    def get_stations(self): return self.stations
    def set_stations(self, stations): self.stations = stations
    def get_numberOfSubArrayPointings(self): return self.numberOfSubArrayPointings
    def set_numberOfSubArrayPointings(self, numberOfSubArrayPointings): self.numberOfSubArrayPointings = numberOfSubArrayPointings
    def get_subArrayPointings(self): return self.subArrayPointings
    def set_subArrayPointings(self, subArrayPointings): self.subArrayPointings = subArrayPointings
    def get_numberOftransientBufferBoardEvents(self): return self.numberOftransientBufferBoardEvents
    def set_numberOftransientBufferBoardEvents(self, numberOftransientBufferBoardEvents): self.numberOftransientBufferBoardEvents = numberOftransientBufferBoardEvents
    def get_transientBufferBoardEvents(self): return self.transientBufferBoardEvents
    def set_transientBufferBoardEvents(self, transientBufferBoardEvents): self.transientBufferBoardEvents = transientBufferBoardEvents
    def get_numberOfCorrelatedDataProducts(self): return self.numberOfCorrelatedDataProducts
    def set_numberOfCorrelatedDataProducts(self, numberOfCorrelatedDataProducts): self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def get_numberOfBeamFormedDataProducts(self): return self.numberOfBeamFormedDataProducts
    def set_numberOfBeamFormedDataProducts(self, numberOfBeamFormedDataProducts): self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def get_numberOfBitsPerSample(self): return self.numberOfBitsPerSample
    def set_numberOfBitsPerSample(self, numberOfBitsPerSample): self.numberOfBitsPerSample = numberOfBitsPerSample
    def export(self, outfile, level, namespace_='', name_='Observation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Observation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Observation'):
        super(Observation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Observation')
    def exportChildren(self, outfile, level, namespace_='', name_='Observation', fromsubclass_=False, pretty_print=True):
        super(Observation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.observingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservingMode>%s</%sobservingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.observingMode).encode(ExternalEncoding), input_name='observingMode'), namespace_, eol_))
        if self.observationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobservationDescription>%s</%sobservationDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.observationDescription).encode(ExternalEncoding), input_name='observationDescription'), namespace_, eol_))
        if self.instrumentFilter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrumentFilter>%s</%sinstrumentFilter>%s' % (namespace_, self.gds_format_string(quote_xml(self.instrumentFilter).encode(ExternalEncoding), input_name='instrumentFilter'), namespace_, eol_))
        if self.clock is not None:
            self.clock.export(outfile, level, namespace_, name_='clock', pretty_print=pretty_print)
        if self.stationSelection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstationSelection>%s</%sstationSelection>%s' % (namespace_, self.gds_format_string(quote_xml(self.stationSelection).encode(ExternalEncoding), input_name='stationSelection'), namespace_, eol_))
        if self.antennaSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%santennaSet>%s</%santennaSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.antennaSet).encode(ExternalEncoding), input_name='antennaSet'), namespace_, eol_))
        if self.timeSystem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeSystem>%s</%stimeSystem>%s' % (namespace_, self.gds_format_string(quote_xml(self.timeSystem).encode(ExternalEncoding), input_name='timeSystem'), namespace_, eol_))
        if self.channelWidth is not None:
            self.channelWidth.export(outfile, level, namespace_, name_='channelWidth', pretty_print=pretty_print)
        if self.channelsPerSubband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schannelsPerSubband>%s</%schannelsPerSubband>%s' % (namespace_, self.gds_format_integer(self.channelsPerSubband, input_name='channelsPerSubband'), namespace_, eol_))
        if self.numberOfStations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfStations>%s</%snumberOfStations>%s' % (namespace_, self.gds_format_integer(self.numberOfStations, input_name='numberOfStations'), namespace_, eol_))
        if self.stations is not None:
            self.stations.export(outfile, level, namespace_, name_='stations', pretty_print=pretty_print)
        if self.numberOfSubArrayPointings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfSubArrayPointings>%s</%snumberOfSubArrayPointings>%s' % (namespace_, self.gds_format_integer(self.numberOfSubArrayPointings, input_name='numberOfSubArrayPointings'), namespace_, eol_))
        if self.subArrayPointings is not None:
            self.subArrayPointings.export(outfile, level, namespace_, name_='subArrayPointings', pretty_print=pretty_print)
        if self.numberOftransientBufferBoardEvents is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOftransientBufferBoardEvents>%s</%snumberOftransientBufferBoardEvents>%s' % (namespace_, self.gds_format_integer(self.numberOftransientBufferBoardEvents, input_name='numberOftransientBufferBoardEvents'), namespace_, eol_))
        if self.transientBufferBoardEvents is not None:
            self.transientBufferBoardEvents.export(outfile, level, namespace_, name_='transientBufferBoardEvents', pretty_print=pretty_print)
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCorrelatedDataProducts>%s</%snumberOfCorrelatedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfCorrelatedDataProducts, input_name='numberOfCorrelatedDataProducts'), namespace_, eol_))
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBeamFormedDataProducts>%s</%snumberOfBeamFormedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfBeamFormedDataProducts, input_name='numberOfBeamFormedDataProducts'), namespace_, eol_))
        if self.numberOfBitsPerSample is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBitsPerSample>%s</%snumberOfBitsPerSample>%s' % (namespace_, self.gds_format_integer(self.numberOfBitsPerSample, input_name='numberOfBitsPerSample'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.observingMode is not None or
            self.observationDescription is not None or
            self.instrumentFilter is not None or
            self.clock is not None or
            self.stationSelection is not None or
            self.antennaSet is not None or
            self.timeSystem is not None or
            self.channelWidth is not None or
            self.channelsPerSubband is not None or
            self.numberOfStations is not None or
            self.stations is not None or
            self.numberOfSubArrayPointings is not None or
            self.subArrayPointings is not None or
            self.numberOftransientBufferBoardEvents is not None or
            self.transientBufferBoardEvents is not None or
            self.numberOfCorrelatedDataProducts is not None or
            self.numberOfBeamFormedDataProducts is not None or
            self.numberOfBitsPerSample is not None or
            super(Observation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Observation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Observation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Observation, self).exportLiteralChildren(outfile, level, name_)
        if self.observingMode is not None:
            showIndent(outfile, level)
            outfile.write('observingMode=%s,\n' % quote_python(self.observingMode).encode(ExternalEncoding))
        if self.observationDescription is not None:
            showIndent(outfile, level)
            outfile.write('observationDescription=%s,\n' % quote_python(self.observationDescription).encode(ExternalEncoding))
        if self.instrumentFilter is not None:
            showIndent(outfile, level)
            outfile.write('instrumentFilter=%s,\n' % quote_python(self.instrumentFilter).encode(ExternalEncoding))
        if self.clock is not None:
            showIndent(outfile, level)
            outfile.write('clock=model_.ClockType(\n')
            self.clock.exportLiteral(outfile, level, name_='clock')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.stationSelection is not None:
            showIndent(outfile, level)
            outfile.write('stationSelection=%s,\n' % quote_python(self.stationSelection).encode(ExternalEncoding))
        if self.antennaSet is not None:
            showIndent(outfile, level)
            outfile.write('antennaSet=%s,\n' % quote_python(self.antennaSet).encode(ExternalEncoding))
        if self.timeSystem is not None:
            showIndent(outfile, level)
            outfile.write('timeSystem=%s,\n' % quote_python(self.timeSystem).encode(ExternalEncoding))
        if self.channelWidth is not None:
            showIndent(outfile, level)
            outfile.write('channelWidth=model_.Frequency(\n')
            self.channelWidth.exportLiteral(outfile, level, name_='channelWidth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.channelsPerSubband is not None:
            showIndent(outfile, level)
            outfile.write('channelsPerSubband=%d,\n' % self.channelsPerSubband)
        if self.numberOfStations is not None:
            showIndent(outfile, level)
            outfile.write('numberOfStations=%d,\n' % self.numberOfStations)
        if self.stations is not None:
            showIndent(outfile, level)
            outfile.write('stations=model_.Stations(\n')
            self.stations.exportLiteral(outfile, level, name_='stations')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.numberOfSubArrayPointings is not None:
            showIndent(outfile, level)
            outfile.write('numberOfSubArrayPointings=%d,\n' % self.numberOfSubArrayPointings)
        if self.subArrayPointings is not None:
            showIndent(outfile, level)
            outfile.write('subArrayPointings=model_.SubArrayPointings(\n')
            self.subArrayPointings.exportLiteral(outfile, level, name_='subArrayPointings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.numberOftransientBufferBoardEvents is not None:
            showIndent(outfile, level)
            outfile.write('numberOftransientBufferBoardEvents=%d,\n' % self.numberOftransientBufferBoardEvents)
        if self.transientBufferBoardEvents is not None:
            showIndent(outfile, level)
            outfile.write('transientBufferBoardEvents=model_.TransientBufferBoardEvents(\n')
            self.transientBufferBoardEvents.exportLiteral(outfile, level, name_='transientBufferBoardEvents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCorrelatedDataProducts=%d,\n' % self.numberOfCorrelatedDataProducts)
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfBeamFormedDataProducts=%d,\n' % self.numberOfBeamFormedDataProducts)
        if self.numberOfBitsPerSample is not None:
            showIndent(outfile, level)
            outfile.write('numberOfBitsPerSample=%d,\n' % self.numberOfBitsPerSample)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Observation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'observingMode':
            observingMode_ = child_.text
            observingMode_ = self.gds_validate_string(observingMode_, node, 'observingMode')
            self.observingMode = observingMode_
            self.validate_ObservingModeType(self.observingMode)    # validate type ObservingModeType
        elif nodeName_ == 'observationDescription':
            observationDescription_ = child_.text
            observationDescription_ = self.gds_validate_string(observationDescription_, node, 'observationDescription')
            self.observationDescription = observationDescription_
        elif nodeName_ == 'instrumentFilter':
            instrumentFilter_ = child_.text
            instrumentFilter_ = self.gds_validate_string(instrumentFilter_, node, 'instrumentFilter')
            self.instrumentFilter = instrumentFilter_
            self.validate_FilterSelectionType(self.instrumentFilter)    # validate type FilterSelectionType
        elif nodeName_ == 'clock':
            obj_ = ClockType.factory()
            obj_.build(child_)
            self.set_clock(obj_)
        elif nodeName_ == 'stationSelection':
            stationSelection_ = child_.text
            stationSelection_ = self.gds_validate_string(stationSelection_, node, 'stationSelection')
            self.stationSelection = stationSelection_
            self.validate_StationSelectionType(self.stationSelection)    # validate type StationSelectionType
        elif nodeName_ == 'antennaSet':
            antennaSet_ = child_.text
            antennaSet_ = self.gds_validate_string(antennaSet_, node, 'antennaSet')
            self.antennaSet = antennaSet_
            self.validate_AntennaSetType(self.antennaSet)    # validate type AntennaSetType
        elif nodeName_ == 'timeSystem':
            timeSystem_ = child_.text
            timeSystem_ = self.gds_validate_string(timeSystem_, node, 'timeSystem')
            self.timeSystem = timeSystem_
            self.validate_TimeSystemType(self.timeSystem)    # validate type TimeSystemType
        elif nodeName_ == 'channelWidth':
            class_obj_ = self.get_class_obj_(child_, Frequency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_channelWidth(obj_)
        elif nodeName_ == 'channelsPerSubband':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'channelsPerSubband')
            self.channelsPerSubband = ival_
        elif nodeName_ == 'numberOfStations':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfStations')
            self.numberOfStations = ival_
        elif nodeName_ == 'stations':
            obj_ = Stations.factory()
            obj_.build(child_)
            self.set_stations(obj_)
        elif nodeName_ == 'numberOfSubArrayPointings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfSubArrayPointings')
            self.numberOfSubArrayPointings = ival_
        elif nodeName_ == 'subArrayPointings':
            obj_ = SubArrayPointings.factory()
            obj_.build(child_)
            self.set_subArrayPointings(obj_)
        elif nodeName_ == 'numberOftransientBufferBoardEvents':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOftransientBufferBoardEvents')
            self.numberOftransientBufferBoardEvents = ival_
        elif nodeName_ == 'transientBufferBoardEvents':
            obj_ = TransientBufferBoardEvents.factory()
            obj_.build(child_)
            self.set_transientBufferBoardEvents(obj_)
        elif nodeName_ == 'numberOfCorrelatedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCorrelatedDataProducts')
            self.numberOfCorrelatedDataProducts = ival_
        elif nodeName_ == 'numberOfBeamFormedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfBeamFormedDataProducts')
            self.numberOfBeamFormedDataProducts = ival_
        elif nodeName_ == 'numberOfBitsPerSample':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfBitsPerSample')
            self.numberOfBitsPerSample = ival_
        super(Observation, self).buildChildren(child_, node, nodeName_, True)
# end class Observation


class DirectDataMeasurement(Process):
    subclass = None
    superclass = Process
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, ObservingMode=None, station=None):
        super(DirectDataMeasurement, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, )
        self.ObservingMode = ObservingMode
        self.station = station
    def factory(*args_, **kwargs_):
        if DirectDataMeasurement.subclass:
            return DirectDataMeasurement.subclass(*args_, **kwargs_)
        else:
            return DirectDataMeasurement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObservingMode(self): return self.ObservingMode
    def set_ObservingMode(self, ObservingMode): self.ObservingMode = ObservingMode
    def validate_ObservingModeType(self, value):
        # Validate type ObservingModeType, a restriction on xs:string.
        pass
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def export(self, outfile, level, namespace_='', name_='DirectDataMeasurement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectDataMeasurement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectDataMeasurement'):
        super(DirectDataMeasurement, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectDataMeasurement')
    def exportChildren(self, outfile, level, namespace_='', name_='DirectDataMeasurement', fromsubclass_=False, pretty_print=True):
        super(DirectDataMeasurement, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObservingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObservingMode>%s</%sObservingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ObservingMode).encode(ExternalEncoding), input_name='ObservingMode'), namespace_, eol_))
        if self.station is not None:
            self.station.export(outfile, level, namespace_, name_='station', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ObservingMode is not None or
            self.station is not None or
            super(DirectDataMeasurement, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectDataMeasurement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DirectDataMeasurement, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DirectDataMeasurement, self).exportLiteralChildren(outfile, level, name_)
        if self.ObservingMode is not None:
            showIndent(outfile, level)
            outfile.write('ObservingMode=%s,\n' % quote_python(self.ObservingMode).encode(ExternalEncoding))
        if self.station is not None:
            showIndent(outfile, level)
            outfile.write('station=model_.Station(\n')
            self.station.exportLiteral(outfile, level, name_='station')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DirectDataMeasurement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObservingMode':
            ObservingMode_ = child_.text
            ObservingMode_ = self.gds_validate_string(ObservingMode_, node, 'ObservingMode')
            self.ObservingMode = ObservingMode_
            self.validate_ObservingModeType(self.ObservingMode)    # validate type ObservingModeType
        elif nodeName_ == 'station':
            obj_ = Station.factory()
            obj_.build(child_)
            self.set_station(obj_)
        super(DirectDataMeasurement, self).buildChildren(child_, node, nodeName_, True)
# end class DirectDataMeasurement


class GenericMeasurement(Process):
    subclass = None
    superclass = Process
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, ObservingMode=None, description=None):
        super(GenericMeasurement, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, )
        self.ObservingMode = ObservingMode
        self.description = description
    def factory(*args_, **kwargs_):
        if GenericMeasurement.subclass:
            return GenericMeasurement.subclass(*args_, **kwargs_)
        else:
            return GenericMeasurement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObservingMode(self): return self.ObservingMode
    def set_ObservingMode(self, ObservingMode): self.ObservingMode = ObservingMode
    def validate_ObservingModeType(self, value):
        # Validate type ObservingModeType, a restriction on xs:string.
        pass
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='GenericMeasurement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMeasurement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericMeasurement'):
        super(GenericMeasurement, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMeasurement')
    def exportChildren(self, outfile, level, namespace_='', name_='GenericMeasurement', fromsubclass_=False, pretty_print=True):
        super(GenericMeasurement, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObservingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObservingMode>%s</%sObservingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ObservingMode).encode(ExternalEncoding), input_name='ObservingMode'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ObservingMode is not None or
            self.description is not None or
            super(GenericMeasurement, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GenericMeasurement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GenericMeasurement, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GenericMeasurement, self).exportLiteralChildren(outfile, level, name_)
        if self.ObservingMode is not None:
            showIndent(outfile, level)
            outfile.write('ObservingMode=%s,\n' % quote_python(self.ObservingMode).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericMeasurement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObservingMode':
            ObservingMode_ = child_.text
            ObservingMode_ = self.gds_validate_string(ObservingMode_, node, 'ObservingMode')
            self.ObservingMode = ObservingMode_
            self.validate_ObservingModeType(self.ObservingMode)    # validate type ObservingModeType
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        super(GenericMeasurement, self).buildChildren(child_, node, nodeName_, True)
# end class GenericMeasurement


class UnspecifiedProcess(Process):
    subclass = None
    superclass = Process
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, ObservingMode=None, description=None):
        super(UnspecifiedProcess, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, )
        self.ObservingMode = ObservingMode
        self.description = description
    def factory(*args_, **kwargs_):
        if UnspecifiedProcess.subclass:
            return UnspecifiedProcess.subclass(*args_, **kwargs_)
        else:
            return UnspecifiedProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObservingMode(self): return self.ObservingMode
    def set_ObservingMode(self, ObservingMode): self.ObservingMode = ObservingMode
    def validate_ObservingModeType(self, value):
        # Validate type ObservingModeType, a restriction on xs:string.
        pass
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def export(self, outfile, level, namespace_='', name_='UnspecifiedProcess', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnspecifiedProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnspecifiedProcess'):
        super(UnspecifiedProcess, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnspecifiedProcess')
    def exportChildren(self, outfile, level, namespace_='', name_='UnspecifiedProcess', fromsubclass_=False, pretty_print=True):
        super(UnspecifiedProcess, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObservingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObservingMode>%s</%sObservingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ObservingMode).encode(ExternalEncoding), input_name='ObservingMode'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ObservingMode is not None or
            self.description is not None or
            super(UnspecifiedProcess, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnspecifiedProcess'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UnspecifiedProcess, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UnspecifiedProcess, self).exportLiteralChildren(outfile, level, name_)
        if self.ObservingMode is not None:
            showIndent(outfile, level)
            outfile.write('ObservingMode=%s,\n' % quote_python(self.ObservingMode).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(UnspecifiedProcess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObservingMode':
            ObservingMode_ = child_.text
            ObservingMode_ = self.gds_validate_string(ObservingMode_, node, 'ObservingMode')
            self.ObservingMode = ObservingMode_
            self.validate_ObservingModeType(self.ObservingMode)    # validate type ObservingModeType
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        super(UnspecifiedProcess, self).buildChildren(child_, node, nodeName_, True)
# end class UnspecifiedProcess


class Processing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, correlator=None, coherentStokes=None, incoherentStokes=None, flysEye=None, nonStandard=None):
        self.correlator = correlator
        self.coherentStokes = coherentStokes
        self.incoherentStokes = incoherentStokes
        self.flysEye = flysEye
        self.nonStandard = nonStandard
    def factory(*args_, **kwargs_):
        if Processing.subclass:
            return Processing.subclass(*args_, **kwargs_)
        else:
            return Processing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_correlator(self): return self.correlator
    def set_correlator(self, correlator): self.correlator = correlator
    def get_coherentStokes(self): return self.coherentStokes
    def set_coherentStokes(self, coherentStokes): self.coherentStokes = coherentStokes
    def get_incoherentStokes(self): return self.incoherentStokes
    def set_incoherentStokes(self, incoherentStokes): self.incoherentStokes = incoherentStokes
    def get_flysEye(self): return self.flysEye
    def set_flysEye(self, flysEye): self.flysEye = flysEye
    def get_nonStandard(self): return self.nonStandard
    def set_nonStandard(self, nonStandard): self.nonStandard = nonStandard
    def export(self, outfile, level, namespace_='', name_='Processing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Processing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Processing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Processing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.correlator is not None:
            self.correlator.export(outfile, level, namespace_, name_='correlator', pretty_print=pretty_print)
        if self.coherentStokes is not None:
            self.coherentStokes.export(outfile, level, namespace_, name_='coherentStokes', pretty_print=pretty_print)
        if self.incoherentStokes is not None:
            self.incoherentStokes.export(outfile, level, namespace_, name_='incoherentStokes', pretty_print=pretty_print)
        if self.flysEye is not None:
            self.flysEye.export(outfile, level, namespace_, name_='flysEye', pretty_print=pretty_print)
        if self.nonStandard is not None:
            self.nonStandard.export(outfile, level, namespace_, name_='nonStandard', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.correlator is not None or
            self.coherentStokes is not None or
            self.incoherentStokes is not None or
            self.flysEye is not None or
            self.nonStandard is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Processing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.correlator is not None:
            showIndent(outfile, level)
            outfile.write('correlator=model_.Correlator(\n')
            self.correlator.exportLiteral(outfile, level, name_='correlator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coherentStokes is not None:
            showIndent(outfile, level)
            outfile.write('coherentStokes=model_.CoherentStokes(\n')
            self.coherentStokes.exportLiteral(outfile, level, name_='coherentStokes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.incoherentStokes is not None:
            showIndent(outfile, level)
            outfile.write('incoherentStokes=model_.IncoherentStokes(\n')
            self.incoherentStokes.exportLiteral(outfile, level, name_='incoherentStokes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flysEye is not None:
            showIndent(outfile, level)
            outfile.write('flysEye=model_.FlysEye(\n')
            self.flysEye.exportLiteral(outfile, level, name_='flysEye')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nonStandard is not None:
            showIndent(outfile, level)
            outfile.write('nonStandard=model_.NonStandard(\n')
            self.nonStandard.exportLiteral(outfile, level, name_='nonStandard')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'correlator':
            obj_ = Correlator.factory()
            obj_.build(child_)
            self.set_correlator(obj_)
        elif nodeName_ == 'coherentStokes':
            obj_ = CoherentStokes.factory()
            obj_.build(child_)
            self.set_coherentStokes(obj_)
        elif nodeName_ == 'incoherentStokes':
            obj_ = IncoherentStokes.factory()
            obj_.build(child_)
            self.set_incoherentStokes(obj_)
        elif nodeName_ == 'flysEye':
            obj_ = FlysEye.factory()
            obj_.build(child_)
            self.set_flysEye(obj_)
        elif nodeName_ == 'nonStandard':
            obj_ = NonStandard.factory()
            obj_.build(child_)
            self.set_nonStandard(obj_)
# end class Processing


class RealTimeProcess(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, processingType=None, extensiontype_=None):
        self.processingType = processingType
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if RealTimeProcess.subclass:
            return RealTimeProcess.subclass(*args_, **kwargs_)
        else:
            return RealTimeProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processingType(self): return self.processingType
    def set_processingType(self, processingType): self.processingType = processingType
    def validate_ProcessingType(self, value):
        # Validate type ProcessingType, a restriction on xs:string.
        pass
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='RealTimeProcess', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RealTimeProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RealTimeProcess'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RealTimeProcess', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessingType>%s</%sprocessingType>%s' % (namespace_, self.gds_format_string(quote_xml(self.processingType).encode(ExternalEncoding), input_name='processingType'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.processingType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RealTimeProcess'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processingType is not None:
            showIndent(outfile, level)
            outfile.write('processingType=%s,\n' % quote_python(self.processingType).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processingType':
            processingType_ = child_.text
            processingType_ = self.gds_validate_string(processingType_, node, 'processingType')
            self.processingType = processingType_
            self.validate_ProcessingType(self.processingType)    # validate type ProcessingType
# end class RealTimeProcess


class Correlator(RealTimeProcess):
    subclass = None
    superclass = RealTimeProcess
    def __init__(self, processingType=None, integrationInterval=None):
        super(Correlator, self).__init__(processingType, )
        self.integrationInterval = integrationInterval
    def factory(*args_, **kwargs_):
        if Correlator.subclass:
            return Correlator.subclass(*args_, **kwargs_)
        else:
            return Correlator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_integrationInterval(self): return self.integrationInterval
    def set_integrationInterval(self, integrationInterval): self.integrationInterval = integrationInterval
    def export(self, outfile, level, namespace_='', name_='Correlator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Correlator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Correlator'):
        super(Correlator, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Correlator')
    def exportChildren(self, outfile, level, namespace_='', name_='Correlator', fromsubclass_=False, pretty_print=True):
        super(Correlator, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.integrationInterval is not None:
            self.integrationInterval.export(outfile, level, namespace_, name_='integrationInterval', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.integrationInterval is not None or
            super(Correlator, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Correlator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Correlator, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Correlator, self).exportLiteralChildren(outfile, level, name_)
        if self.integrationInterval is not None:
            showIndent(outfile, level)
            outfile.write('integrationInterval=model_.Time(\n')
            self.integrationInterval.exportLiteral(outfile, level, name_='integrationInterval')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Correlator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'integrationInterval':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_integrationInterval(obj_)
        super(Correlator, self).buildChildren(child_, node, nodeName_, True)
# end class Correlator


class CoherentStokes(RealTimeProcess):
    subclass = None
    superclass = RealTimeProcess
    def __init__(self, processingType=None, rawSamplingTime=None, timeDownsamplingFactor=None, samplingTime=None, frequencyDownsamplingFactor=None, numberOfCollapsedChannels=None, stokes=None, numberOfStations=None, stations=None):
        super(CoherentStokes, self).__init__(processingType, )
        self.rawSamplingTime = rawSamplingTime
        self.timeDownsamplingFactor = timeDownsamplingFactor
        self.samplingTime = samplingTime
        self.frequencyDownsamplingFactor = frequencyDownsamplingFactor
        self.numberOfCollapsedChannels = numberOfCollapsedChannels
        if stokes is None:
            self.stokes = []
        else:
            self.stokes = stokes
        self.numberOfStations = numberOfStations
        self.stations = stations
    def factory(*args_, **kwargs_):
        if CoherentStokes.subclass:
            return CoherentStokes.subclass(*args_, **kwargs_)
        else:
            return CoherentStokes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rawSamplingTime(self): return self.rawSamplingTime
    def set_rawSamplingTime(self, rawSamplingTime): self.rawSamplingTime = rawSamplingTime
    def get_timeDownsamplingFactor(self): return self.timeDownsamplingFactor
    def set_timeDownsamplingFactor(self, timeDownsamplingFactor): self.timeDownsamplingFactor = timeDownsamplingFactor
    def get_samplingTime(self): return self.samplingTime
    def set_samplingTime(self, samplingTime): self.samplingTime = samplingTime
    def get_frequencyDownsamplingFactor(self): return self.frequencyDownsamplingFactor
    def set_frequencyDownsamplingFactor(self, frequencyDownsamplingFactor): self.frequencyDownsamplingFactor = frequencyDownsamplingFactor
    def get_numberOfCollapsedChannels(self): return self.numberOfCollapsedChannels
    def set_numberOfCollapsedChannels(self, numberOfCollapsedChannels): self.numberOfCollapsedChannels = numberOfCollapsedChannels
    def get_stokes(self): return self.stokes
    def set_stokes(self, stokes): self.stokes = stokes
    def add_stokes(self, value): self.stokes.append(value)
    def insert_stokes(self, index, value): self.stokes[index] = value
    def validate_PolarizationType(self, value):
        # Validate type PolarizationType, a restriction on xs:string.
        pass
    def get_numberOfStations(self): return self.numberOfStations
    def set_numberOfStations(self, numberOfStations): self.numberOfStations = numberOfStations
    def get_stations(self): return self.stations
    def set_stations(self, stations): self.stations = stations
    def export(self, outfile, level, namespace_='', name_='CoherentStokes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoherentStokes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoherentStokes'):
        super(CoherentStokes, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoherentStokes')
    def exportChildren(self, outfile, level, namespace_='', name_='CoherentStokes', fromsubclass_=False, pretty_print=True):
        super(CoherentStokes, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rawSamplingTime is not None:
            self.rawSamplingTime.export(outfile, level, namespace_, name_='rawSamplingTime', pretty_print=pretty_print)
        if self.timeDownsamplingFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeDownsamplingFactor>%s</%stimeDownsamplingFactor>%s' % (namespace_, self.gds_format_integer(self.timeDownsamplingFactor, input_name='timeDownsamplingFactor'), namespace_, eol_))
        if self.samplingTime is not None:
            self.samplingTime.export(outfile, level, namespace_, name_='samplingTime', pretty_print=pretty_print)
        if self.frequencyDownsamplingFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrequencyDownsamplingFactor>%s</%sfrequencyDownsamplingFactor>%s' % (namespace_, self.gds_format_integer(self.frequencyDownsamplingFactor, input_name='frequencyDownsamplingFactor'), namespace_, eol_))
        if self.numberOfCollapsedChannels is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCollapsedChannels>%s</%snumberOfCollapsedChannels>%s' % (namespace_, self.gds_format_integer(self.numberOfCollapsedChannels, input_name='numberOfCollapsedChannels'), namespace_, eol_))
        for stokes_ in self.stokes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstokes>%s</%sstokes>%s' % (namespace_, self.gds_format_string(quote_xml(stokes_).encode(ExternalEncoding), input_name='stokes'), namespace_, eol_))
        if self.numberOfStations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfStations>%s</%snumberOfStations>%s' % (namespace_, self.gds_format_integer(self.numberOfStations, input_name='numberOfStations'), namespace_, eol_))
        if self.stations is not None:
            self.stations.export(outfile, level, namespace_, name_='stations', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.rawSamplingTime is not None or
            self.timeDownsamplingFactor is not None or
            self.samplingTime is not None or
            self.frequencyDownsamplingFactor is not None or
            self.numberOfCollapsedChannels is not None or
            self.stokes or
            self.numberOfStations is not None or
            self.stations is not None or
            super(CoherentStokes, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoherentStokes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CoherentStokes, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CoherentStokes, self).exportLiteralChildren(outfile, level, name_)
        if self.rawSamplingTime is not None:
            showIndent(outfile, level)
            outfile.write('rawSamplingTime=model_.Time(\n')
            self.rawSamplingTime.exportLiteral(outfile, level, name_='rawSamplingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeDownsamplingFactor is not None:
            showIndent(outfile, level)
            outfile.write('timeDownsamplingFactor=%d,\n' % self.timeDownsamplingFactor)
        if self.samplingTime is not None:
            showIndent(outfile, level)
            outfile.write('samplingTime=model_.Time(\n')
            self.samplingTime.exportLiteral(outfile, level, name_='samplingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.frequencyDownsamplingFactor is not None:
            showIndent(outfile, level)
            outfile.write('frequencyDownsamplingFactor=%d,\n' % self.frequencyDownsamplingFactor)
        if self.numberOfCollapsedChannels is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCollapsedChannels=%d,\n' % self.numberOfCollapsedChannels)
        showIndent(outfile, level)
        outfile.write('stokes=[\n')
        level += 1
        for stokes_ in self.stokes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stokes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.numberOfStations is not None:
            showIndent(outfile, level)
            outfile.write('numberOfStations=%d,\n' % self.numberOfStations)
        if self.stations is not None:
            showIndent(outfile, level)
            outfile.write('stations=model_.Stations(\n')
            self.stations.exportLiteral(outfile, level, name_='stations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CoherentStokes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rawSamplingTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_rawSamplingTime(obj_)
        elif nodeName_ == 'timeDownsamplingFactor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeDownsamplingFactor')
            self.timeDownsamplingFactor = ival_
        elif nodeName_ == 'samplingTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_samplingTime(obj_)
        elif nodeName_ == 'frequencyDownsamplingFactor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'frequencyDownsamplingFactor')
            self.frequencyDownsamplingFactor = ival_
        elif nodeName_ == 'numberOfCollapsedChannels':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCollapsedChannels')
            self.numberOfCollapsedChannels = ival_
        elif nodeName_ == 'stokes':
            stokes_ = child_.text
            stokes_ = self.gds_validate_string(stokes_, node, 'stokes')
            self.stokes.append(stokes_)
            self.validate_PolarizationType(self.stokes)    # validate type PolarizationType
        elif nodeName_ == 'numberOfStations':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfStations')
            self.numberOfStations = ival_
        elif nodeName_ == 'stations':
            obj_ = Stations.factory()
            obj_.build(child_)
            self.set_stations(obj_)
        super(CoherentStokes, self).buildChildren(child_, node, nodeName_, True)
# end class CoherentStokes


class IncoherentStokes(RealTimeProcess):
    subclass = None
    superclass = RealTimeProcess
    def __init__(self, processingType=None, rawSamplingTime=None, timeDownsamplingFactor=None, samplingTime=None, frequencyDownsamplingFactor=None, numberOfCollapsedChannels=None, stokes=None, numberOfStations=None, stations=None):
        super(IncoherentStokes, self).__init__(processingType, )
        self.rawSamplingTime = rawSamplingTime
        self.timeDownsamplingFactor = timeDownsamplingFactor
        self.samplingTime = samplingTime
        self.frequencyDownsamplingFactor = frequencyDownsamplingFactor
        self.numberOfCollapsedChannels = numberOfCollapsedChannels
        if stokes is None:
            self.stokes = []
        else:
            self.stokes = stokes
        self.numberOfStations = numberOfStations
        self.stations = stations
    def factory(*args_, **kwargs_):
        if IncoherentStokes.subclass:
            return IncoherentStokes.subclass(*args_, **kwargs_)
        else:
            return IncoherentStokes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rawSamplingTime(self): return self.rawSamplingTime
    def set_rawSamplingTime(self, rawSamplingTime): self.rawSamplingTime = rawSamplingTime
    def get_timeDownsamplingFactor(self): return self.timeDownsamplingFactor
    def set_timeDownsamplingFactor(self, timeDownsamplingFactor): self.timeDownsamplingFactor = timeDownsamplingFactor
    def get_samplingTime(self): return self.samplingTime
    def set_samplingTime(self, samplingTime): self.samplingTime = samplingTime
    def get_frequencyDownsamplingFactor(self): return self.frequencyDownsamplingFactor
    def set_frequencyDownsamplingFactor(self, frequencyDownsamplingFactor): self.frequencyDownsamplingFactor = frequencyDownsamplingFactor
    def get_numberOfCollapsedChannels(self): return self.numberOfCollapsedChannels
    def set_numberOfCollapsedChannels(self, numberOfCollapsedChannels): self.numberOfCollapsedChannels = numberOfCollapsedChannels
    def get_stokes(self): return self.stokes
    def set_stokes(self, stokes): self.stokes = stokes
    def add_stokes(self, value): self.stokes.append(value)
    def insert_stokes(self, index, value): self.stokes[index] = value
    def validate_PolarizationType(self, value):
        # Validate type PolarizationType, a restriction on xs:string.
        pass
    def get_numberOfStations(self): return self.numberOfStations
    def set_numberOfStations(self, numberOfStations): self.numberOfStations = numberOfStations
    def get_stations(self): return self.stations
    def set_stations(self, stations): self.stations = stations
    def export(self, outfile, level, namespace_='', name_='IncoherentStokes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncoherentStokes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IncoherentStokes'):
        super(IncoherentStokes, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IncoherentStokes')
    def exportChildren(self, outfile, level, namespace_='', name_='IncoherentStokes', fromsubclass_=False, pretty_print=True):
        super(IncoherentStokes, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rawSamplingTime is not None:
            self.rawSamplingTime.export(outfile, level, namespace_, name_='rawSamplingTime', pretty_print=pretty_print)
        if self.timeDownsamplingFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeDownsamplingFactor>%s</%stimeDownsamplingFactor>%s' % (namespace_, self.gds_format_integer(self.timeDownsamplingFactor, input_name='timeDownsamplingFactor'), namespace_, eol_))
        if self.samplingTime is not None:
            self.samplingTime.export(outfile, level, namespace_, name_='samplingTime', pretty_print=pretty_print)
        if self.frequencyDownsamplingFactor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrequencyDownsamplingFactor>%s</%sfrequencyDownsamplingFactor>%s' % (namespace_, self.gds_format_integer(self.frequencyDownsamplingFactor, input_name='frequencyDownsamplingFactor'), namespace_, eol_))
        if self.numberOfCollapsedChannels is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCollapsedChannels>%s</%snumberOfCollapsedChannels>%s' % (namespace_, self.gds_format_integer(self.numberOfCollapsedChannels, input_name='numberOfCollapsedChannels'), namespace_, eol_))
        for stokes_ in self.stokes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstokes>%s</%sstokes>%s' % (namespace_, self.gds_format_string(quote_xml(stokes_).encode(ExternalEncoding), input_name='stokes'), namespace_, eol_))
        if self.numberOfStations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfStations>%s</%snumberOfStations>%s' % (namespace_, self.gds_format_integer(self.numberOfStations, input_name='numberOfStations'), namespace_, eol_))
        if self.stations is not None:
            self.stations.export(outfile, level, namespace_, name_='stations', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.rawSamplingTime is not None or
            self.timeDownsamplingFactor is not None or
            self.samplingTime is not None or
            self.frequencyDownsamplingFactor is not None or
            self.numberOfCollapsedChannels is not None or
            self.stokes or
            self.numberOfStations is not None or
            self.stations is not None or
            super(IncoherentStokes, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IncoherentStokes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IncoherentStokes, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IncoherentStokes, self).exportLiteralChildren(outfile, level, name_)
        if self.rawSamplingTime is not None:
            showIndent(outfile, level)
            outfile.write('rawSamplingTime=model_.Time(\n')
            self.rawSamplingTime.exportLiteral(outfile, level, name_='rawSamplingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeDownsamplingFactor is not None:
            showIndent(outfile, level)
            outfile.write('timeDownsamplingFactor=%d,\n' % self.timeDownsamplingFactor)
        if self.samplingTime is not None:
            showIndent(outfile, level)
            outfile.write('samplingTime=model_.Time(\n')
            self.samplingTime.exportLiteral(outfile, level, name_='samplingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.frequencyDownsamplingFactor is not None:
            showIndent(outfile, level)
            outfile.write('frequencyDownsamplingFactor=%d,\n' % self.frequencyDownsamplingFactor)
        if self.numberOfCollapsedChannels is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCollapsedChannels=%d,\n' % self.numberOfCollapsedChannels)
        showIndent(outfile, level)
        outfile.write('stokes=[\n')
        level += 1
        for stokes_ in self.stokes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stokes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.numberOfStations is not None:
            showIndent(outfile, level)
            outfile.write('numberOfStations=%d,\n' % self.numberOfStations)
        if self.stations is not None:
            showIndent(outfile, level)
            outfile.write('stations=model_.Stations(\n')
            self.stations.exportLiteral(outfile, level, name_='stations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(IncoherentStokes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rawSamplingTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_rawSamplingTime(obj_)
        elif nodeName_ == 'timeDownsamplingFactor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeDownsamplingFactor')
            self.timeDownsamplingFactor = ival_
        elif nodeName_ == 'samplingTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_samplingTime(obj_)
        elif nodeName_ == 'frequencyDownsamplingFactor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'frequencyDownsamplingFactor')
            self.frequencyDownsamplingFactor = ival_
        elif nodeName_ == 'numberOfCollapsedChannels':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCollapsedChannels')
            self.numberOfCollapsedChannels = ival_
        elif nodeName_ == 'stokes':
            stokes_ = child_.text
            stokes_ = self.gds_validate_string(stokes_, node, 'stokes')
            self.stokes.append(stokes_)
            self.validate_PolarizationType(self.stokes)    # validate type PolarizationType
        elif nodeName_ == 'numberOfStations':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfStations')
            self.numberOfStations = ival_
        elif nodeName_ == 'stations':
            obj_ = Stations.factory()
            obj_.build(child_)
            self.set_stations(obj_)
        super(IncoherentStokes, self).buildChildren(child_, node, nodeName_, True)
# end class IncoherentStokes


class FlysEye(RealTimeProcess):
    subclass = None
    superclass = RealTimeProcess
    def __init__(self, processingType=None, samplingTime=None, stokes=None):
        super(FlysEye, self).__init__(processingType, )
        self.samplingTime = samplingTime
        if stokes is None:
            self.stokes = []
        else:
            self.stokes = stokes
    def factory(*args_, **kwargs_):
        if FlysEye.subclass:
            return FlysEye.subclass(*args_, **kwargs_)
        else:
            return FlysEye(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_samplingTime(self): return self.samplingTime
    def set_samplingTime(self, samplingTime): self.samplingTime = samplingTime
    def get_stokes(self): return self.stokes
    def set_stokes(self, stokes): self.stokes = stokes
    def add_stokes(self, value): self.stokes.append(value)
    def insert_stokes(self, index, value): self.stokes[index] = value
    def validate_PolarizationType(self, value):
        # Validate type PolarizationType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='FlysEye', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlysEye')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlysEye'):
        super(FlysEye, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlysEye')
    def exportChildren(self, outfile, level, namespace_='', name_='FlysEye', fromsubclass_=False, pretty_print=True):
        super(FlysEye, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.samplingTime is not None:
            self.samplingTime.export(outfile, level, namespace_, name_='samplingTime', pretty_print=pretty_print)
        for stokes_ in self.stokes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstokes>%s</%sstokes>%s' % (namespace_, self.gds_format_string(quote_xml(stokes_).encode(ExternalEncoding), input_name='stokes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.samplingTime is not None or
            self.stokes or
            super(FlysEye, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FlysEye'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlysEye, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlysEye, self).exportLiteralChildren(outfile, level, name_)
        if self.samplingTime is not None:
            showIndent(outfile, level)
            outfile.write('samplingTime=model_.Time(\n')
            self.samplingTime.exportLiteral(outfile, level, name_='samplingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stokes=[\n')
        level += 1
        for stokes_ in self.stokes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stokes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(FlysEye, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'samplingTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_samplingTime(obj_)
        elif nodeName_ == 'stokes':
            stokes_ = child_.text
            stokes_ = self.gds_validate_string(stokes_, node, 'stokes')
            self.stokes.append(stokes_)
            self.validate_PolarizationType(self.stokes)    # validate type PolarizationType
        super(FlysEye, self).buildChildren(child_, node, nodeName_, True)
# end class FlysEye


class NonStandard(RealTimeProcess):
    subclass = None
    superclass = RealTimeProcess
    def __init__(self, processingType=None):
        super(NonStandard, self).__init__(processingType, )
        pass
    def factory(*args_, **kwargs_):
        if NonStandard.subclass:
            return NonStandard.subclass(*args_, **kwargs_)
        else:
            return NonStandard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='NonStandard', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonStandard')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonStandard'):
        super(NonStandard, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NonStandard')
    def exportChildren(self, outfile, level, namespace_='', name_='NonStandard', fromsubclass_=False, pretty_print=True):
        super(NonStandard, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(NonStandard, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NonStandard'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NonStandard, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NonStandard, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(NonStandard, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NonStandard, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NonStandard


class TransientBufferBoardEvents(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transientBufferBoardEvent=None):
        if transientBufferBoardEvent is None:
            self.transientBufferBoardEvent = []
        else:
            self.transientBufferBoardEvent = transientBufferBoardEvent
    def factory(*args_, **kwargs_):
        if TransientBufferBoardEvents.subclass:
            return TransientBufferBoardEvents.subclass(*args_, **kwargs_)
        else:
            return TransientBufferBoardEvents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transientBufferBoardEvent(self): return self.transientBufferBoardEvent
    def set_transientBufferBoardEvent(self, transientBufferBoardEvent): self.transientBufferBoardEvent = transientBufferBoardEvent
    def add_transientBufferBoardEvent(self, value): self.transientBufferBoardEvent.append(value)
    def insert_transientBufferBoardEvent(self, index, value): self.transientBufferBoardEvent[index] = value
    def export(self, outfile, level, namespace_='', name_='TransientBufferBoardEvents', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransientBufferBoardEvents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransientBufferBoardEvents'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransientBufferBoardEvents', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for transientBufferBoardEvent_ in self.transientBufferBoardEvent:
            transientBufferBoardEvent_.export(outfile, level, namespace_, name_='transientBufferBoardEvent', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.transientBufferBoardEvent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransientBufferBoardEvents'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('transientBufferBoardEvent=[\n')
        level += 1
        for transientBufferBoardEvent_ in self.transientBufferBoardEvent:
            showIndent(outfile, level)
            outfile.write('model_.TransientBufferBoardEvent(\n')
            transientBufferBoardEvent_.exportLiteral(outfile, level, name_='TransientBufferBoardEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transientBufferBoardEvent':
            obj_ = TransientBufferBoardEvent.factory()
            obj_.build(child_)
            self.transientBufferBoardEvent.append(obj_)
# end class TransientBufferBoardEvents


class TransientBufferBoardEvent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, eventSource=None):
        self.eventSource = eventSource
    def factory(*args_, **kwargs_):
        if TransientBufferBoardEvent.subclass:
            return TransientBufferBoardEvent.subclass(*args_, **kwargs_)
        else:
            return TransientBufferBoardEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventSource(self): return self.eventSource
    def set_eventSource(self, eventSource): self.eventSource = eventSource
    def export(self, outfile, level, namespace_='', name_='TransientBufferBoardEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransientBufferBoardEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransientBufferBoardEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransientBufferBoardEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.eventSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seventSource>%s</%seventSource>%s' % (namespace_, self.gds_format_string(quote_xml(self.eventSource).encode(ExternalEncoding), input_name='eventSource'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.eventSource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransientBufferBoardEvent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.eventSource is not None:
            showIndent(outfile, level)
            outfile.write('eventSource=%s,\n' % quote_python(self.eventSource).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eventSource':
            eventSource_ = child_.text
            eventSource_ = self.gds_validate_string(eventSource_, node, 'eventSource')
            self.eventSource = eventSource_
# end class TransientBufferBoardEvent


class SubArrayPointings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subArrayPointing=None):
        if subArrayPointing is None:
            self.subArrayPointing = []
        else:
            self.subArrayPointing = subArrayPointing
    def factory(*args_, **kwargs_):
        if SubArrayPointings.subclass:
            return SubArrayPointings.subclass(*args_, **kwargs_)
        else:
            return SubArrayPointings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subArrayPointing(self): return self.subArrayPointing
    def set_subArrayPointing(self, subArrayPointing): self.subArrayPointing = subArrayPointing
    def add_subArrayPointing(self, value): self.subArrayPointing.append(value)
    def insert_subArrayPointing(self, index, value): self.subArrayPointing[index] = value
    def export(self, outfile, level, namespace_='', name_='SubArrayPointings', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubArrayPointings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubArrayPointings'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubArrayPointings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for subArrayPointing_ in self.subArrayPointing:
            subArrayPointing_.export(outfile, level, namespace_, name_='subArrayPointing', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.subArrayPointing
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubArrayPointings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subArrayPointing=[\n')
        level += 1
        for subArrayPointing_ in self.subArrayPointing:
            showIndent(outfile, level)
            outfile.write('model_.SubArrayPointing(\n')
            subArrayPointing_.exportLiteral(outfile, level, name_='SubArrayPointing')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subArrayPointing':
            obj_ = SubArrayPointing.factory()
            obj_.build(child_)
            self.subArrayPointing.append(obj_)
# end class SubArrayPointings


class SubArrayPointing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pointing=None, beamNumber=None, measurementDescription=None, subArrayPointingIdentifier=None, measurementType=None, targetName=None, startTime=None, duration=None, numberOfProcessing=None, processing=None, numberOfCorrelatedDataProducts=None, numberOfBeamFormedDataProducts=None):
        self.pointing = pointing
        self.beamNumber = beamNumber
        self.measurementDescription = measurementDescription
        self.subArrayPointingIdentifier = subArrayPointingIdentifier
        self.measurementType = measurementType
        self.targetName = targetName
        self.startTime = startTime
        self.duration = duration
        self.numberOfProcessing = numberOfProcessing
        self.processing = processing
        self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
        self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def factory(*args_, **kwargs_):
        if SubArrayPointing.subclass:
            return SubArrayPointing.subclass(*args_, **kwargs_)
        else:
            return SubArrayPointing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pointing(self): return self.pointing
    def set_pointing(self, pointing): self.pointing = pointing
    def get_beamNumber(self): return self.beamNumber
    def set_beamNumber(self, beamNumber): self.beamNumber = beamNumber
    def get_measurementDescription(self): return self.measurementDescription
    def set_measurementDescription(self, measurementDescription): self.measurementDescription = measurementDescription
    def get_subArrayPointingIdentifier(self): return self.subArrayPointingIdentifier
    def set_subArrayPointingIdentifier(self, subArrayPointingIdentifier): self.subArrayPointingIdentifier = subArrayPointingIdentifier
    def get_measurementType(self): return self.measurementType
    def set_measurementType(self, measurementType): self.measurementType = measurementType
    def validate_MeasurementType(self, value):
        # Validate type MeasurementType, a restriction on xs:string.
        pass
    def get_targetName(self): return self.targetName
    def set_targetName(self, targetName): self.targetName = targetName
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_numberOfProcessing(self): return self.numberOfProcessing
    def set_numberOfProcessing(self, numberOfProcessing): self.numberOfProcessing = numberOfProcessing
    def get_processing(self): return self.processing
    def set_processing(self, processing): self.processing = processing
    def get_numberOfCorrelatedDataProducts(self): return self.numberOfCorrelatedDataProducts
    def set_numberOfCorrelatedDataProducts(self, numberOfCorrelatedDataProducts): self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def get_numberOfBeamFormedDataProducts(self): return self.numberOfBeamFormedDataProducts
    def set_numberOfBeamFormedDataProducts(self, numberOfBeamFormedDataProducts): self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def export(self, outfile, level, namespace_='', name_='SubArrayPointing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubArrayPointing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubArrayPointing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubArrayPointing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pointing is not None:
            self.pointing.export(outfile, level, namespace_, name_='pointing', pretty_print=pretty_print)
        if self.beamNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeamNumber>%s</%sbeamNumber>%s' % (namespace_, self.gds_format_integer(self.beamNumber, input_name='beamNumber'), namespace_, eol_))
        if self.measurementDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasurementDescription>%s</%smeasurementDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.measurementDescription).encode(ExternalEncoding), input_name='measurementDescription'), namespace_, eol_))
        if self.subArrayPointingIdentifier is not None:
            self.subArrayPointingIdentifier.export(outfile, level, namespace_, name_='subArrayPointingIdentifier', pretty_print=pretty_print)
        if self.measurementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smeasurementType>%s</%smeasurementType>%s' % (namespace_, self.gds_format_string(quote_xml(self.measurementType).encode(ExternalEncoding), input_name='measurementType'), namespace_, eol_))
        if self.targetName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stargetName>%s</%stargetName>%s' % (namespace_, self.gds_format_string(quote_xml(self.targetName).encode(ExternalEncoding), input_name='targetName'), namespace_, eol_))
        if self.startTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartTime>%s</%sstartTime>%s' % (namespace_, self.gds_format_datetime(self.startTime, input_name='startTime'), namespace_, eol_))
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespace_, self.gds_format_string(quote_xml(self.duration).encode(ExternalEncoding), input_name='duration'), namespace_, eol_))
        if self.numberOfProcessing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfProcessing>%s</%snumberOfProcessing>%s' % (namespace_, self.gds_format_integer(self.numberOfProcessing, input_name='numberOfProcessing'), namespace_, eol_))
        if self.processing is not None:
            self.processing.export(outfile, level, namespace_, name_='processing', pretty_print=pretty_print)
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCorrelatedDataProducts>%s</%snumberOfCorrelatedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfCorrelatedDataProducts, input_name='numberOfCorrelatedDataProducts'), namespace_, eol_))
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBeamFormedDataProducts>%s</%snumberOfBeamFormedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfBeamFormedDataProducts, input_name='numberOfBeamFormedDataProducts'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.pointing is not None or
            self.beamNumber is not None or
            self.measurementDescription is not None or
            self.subArrayPointingIdentifier is not None or
            self.measurementType is not None or
            self.targetName is not None or
            self.startTime is not None or
            self.duration is not None or
            self.numberOfProcessing is not None or
            self.processing is not None or
            self.numberOfCorrelatedDataProducts is not None or
            self.numberOfBeamFormedDataProducts is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubArrayPointing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pointing is not None:
            showIndent(outfile, level)
            outfile.write('pointing=model_.Pointing(\n')
            self.pointing.exportLiteral(outfile, level, name_='pointing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.beamNumber is not None:
            showIndent(outfile, level)
            outfile.write('beamNumber=%d,\n' % self.beamNumber)
        if self.measurementDescription is not None:
            showIndent(outfile, level)
            outfile.write('measurementDescription=%s,\n' % quote_python(self.measurementDescription).encode(ExternalEncoding))
        if self.subArrayPointingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('subArrayPointingIdentifier=model_.IdentifierType(\n')
            self.subArrayPointingIdentifier.exportLiteral(outfile, level, name_='subArrayPointingIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.measurementType is not None:
            showIndent(outfile, level)
            outfile.write('measurementType=%s,\n' % quote_python(self.measurementType).encode(ExternalEncoding))
        if self.targetName is not None:
            showIndent(outfile, level)
            outfile.write('targetName=%s,\n' % quote_python(self.targetName).encode(ExternalEncoding))
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=%s,\n' % quote_python(self.duration).encode(ExternalEncoding))
        if self.numberOfProcessing is not None:
            showIndent(outfile, level)
            outfile.write('numberOfProcessing=%d,\n' % self.numberOfProcessing)
        if self.processing is not None:
            showIndent(outfile, level)
            outfile.write('processing=model_.Processing(\n')
            self.processing.exportLiteral(outfile, level, name_='processing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCorrelatedDataProducts=%d,\n' % self.numberOfCorrelatedDataProducts)
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfBeamFormedDataProducts=%d,\n' % self.numberOfBeamFormedDataProducts)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pointing':
            obj_ = Pointing.factory()
            obj_.build(child_)
            self.set_pointing(obj_)
        elif nodeName_ == 'beamNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beamNumber')
            self.beamNumber = ival_
        elif nodeName_ == 'measurementDescription':
            measurementDescription_ = child_.text
            measurementDescription_ = self.gds_validate_string(measurementDescription_, node, 'measurementDescription')
            self.measurementDescription = measurementDescription_
        elif nodeName_ == 'subArrayPointingIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_subArrayPointingIdentifier(obj_)
        elif nodeName_ == 'measurementType':
            measurementType_ = child_.text
            measurementType_ = self.gds_validate_string(measurementType_, node, 'measurementType')
            self.measurementType = measurementType_
            self.validate_MeasurementType(self.measurementType)    # validate type MeasurementType
        elif nodeName_ == 'targetName':
            targetName_ = child_.text
            targetName_ = self.gds_validate_string(targetName_, node, 'targetName')
            self.targetName = targetName_
        elif nodeName_ == 'startTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'startTime')
            self.startTime = dval_
        elif nodeName_ == 'duration':
            duration_ = child_.text
            duration_ = self.gds_validate_string(duration_, node, 'duration')
            self.duration = duration_
        elif nodeName_ == 'numberOfProcessing':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfProcessing')
            self.numberOfProcessing = ival_
        elif nodeName_ == 'processing':
            obj_ = Processing.factory()
            obj_.build(child_)
            self.set_processing(obj_)
        elif nodeName_ == 'numberOfCorrelatedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCorrelatedDataProducts')
            self.numberOfCorrelatedDataProducts = ival_
        elif nodeName_ == 'numberOfBeamFormedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfBeamFormedDataProducts')
            self.numberOfBeamFormedDataProducts = ival_
# end class SubArrayPointing


class DataSources(GeneratedsSuper):
    """============================Pipeline============================
    This section describes the various pipelines."""
    subclass = None
    superclass = None
    def __init__(self, dataProductIdentifier=None):
        if dataProductIdentifier is None:
            self.dataProductIdentifier = []
        else:
            self.dataProductIdentifier = dataProductIdentifier
    def factory(*args_, **kwargs_):
        if DataSources.subclass:
            return DataSources.subclass(*args_, **kwargs_)
        else:
            return DataSources(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataProductIdentifier(self): return self.dataProductIdentifier
    def set_dataProductIdentifier(self, dataProductIdentifier): self.dataProductIdentifier = dataProductIdentifier
    def add_dataProductIdentifier(self, value): self.dataProductIdentifier.append(value)
    def insert_dataProductIdentifier(self, index, value): self.dataProductIdentifier[index] = value
    def export(self, outfile, level, namespace_='', name_='DataSources', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSources')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSources'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataSources', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataProductIdentifier_ in self.dataProductIdentifier:
            dataProductIdentifier_.export(outfile, level, namespace_, name_='dataProductIdentifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.dataProductIdentifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSources'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dataProductIdentifier=[\n')
        level += 1
        for dataProductIdentifier_ in self.dataProductIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            dataProductIdentifier_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataProductIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.dataProductIdentifier.append(obj_)
# end class DataSources


class PipelineRun(Process):
    subclass = None
    superclass = Process
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None, extensiontype_=None):
        super(PipelineRun, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, extensiontype_, )
        self.pipelineName = pipelineName
        self.pipelineVersion = pipelineVersion
        self.sourceData = sourceData
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PipelineRun.subclass:
            return PipelineRun.subclass(*args_, **kwargs_)
        else:
            return PipelineRun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pipelineName(self): return self.pipelineName
    def set_pipelineName(self, pipelineName): self.pipelineName = pipelineName
    def get_pipelineVersion(self): return self.pipelineVersion
    def set_pipelineVersion(self, pipelineVersion): self.pipelineVersion = pipelineVersion
    def get_sourceData(self): return self.sourceData
    def set_sourceData(self, sourceData): self.sourceData = sourceData
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='PipelineRun', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineRun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PipelineRun'):
        super(PipelineRun, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineRun')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PipelineRun', fromsubclass_=False, pretty_print=True):
        super(PipelineRun, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pipelineName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spipelineName>%s</%spipelineName>%s' % (namespace_, self.gds_format_string(quote_xml(self.pipelineName).encode(ExternalEncoding), input_name='pipelineName'), namespace_, eol_))
        if self.pipelineVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spipelineVersion>%s</%spipelineVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.pipelineVersion).encode(ExternalEncoding), input_name='pipelineVersion'), namespace_, eol_))
        if self.sourceData is not None:
            self.sourceData.export(outfile, level, namespace_, name_='sourceData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.pipelineName is not None or
            self.pipelineVersion is not None or
            self.sourceData is not None or
            super(PipelineRun, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PipelineRun'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PipelineRun, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PipelineRun, self).exportLiteralChildren(outfile, level, name_)
        if self.pipelineName is not None:
            showIndent(outfile, level)
            outfile.write('pipelineName=%s,\n' % quote_python(self.pipelineName).encode(ExternalEncoding))
        if self.pipelineVersion is not None:
            showIndent(outfile, level)
            outfile.write('pipelineVersion=%s,\n' % quote_python(self.pipelineVersion).encode(ExternalEncoding))
        if self.sourceData is not None:
            showIndent(outfile, level)
            outfile.write('sourceData=model_.DataSources(\n')
            self.sourceData.exportLiteral(outfile, level, name_='sourceData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(PipelineRun, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pipelineName':
            pipelineName_ = child_.text
            pipelineName_ = self.gds_validate_string(pipelineName_, node, 'pipelineName')
            self.pipelineName = pipelineName_
        elif nodeName_ == 'pipelineVersion':
            pipelineVersion_ = child_.text
            pipelineVersion_ = self.gds_validate_string(pipelineVersion_, node, 'pipelineVersion')
            self.pipelineVersion = pipelineVersion_
        elif nodeName_ == 'sourceData':
            obj_ = DataSources.factory()
            obj_.build(child_)
            self.set_sourceData(obj_)
        super(PipelineRun, self).buildChildren(child_, node, nodeName_, True)
# end class PipelineRun


class ImagingPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None, frequencyIntegrationStep=None, timeIntegrationStep=None, skyModelDatabase=None, demixing=None, imagerIntegrationTime=None, numberOfMajorCycles=None, numberOfInstrumentModels=None, numberOfCorrelatedDataProducts=None, numberOfSkyImages=None):
        super(ImagingPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        self.frequencyIntegrationStep = frequencyIntegrationStep
        self.timeIntegrationStep = timeIntegrationStep
        self.skyModelDatabase = skyModelDatabase
        self.demixing = demixing
        self.imagerIntegrationTime = imagerIntegrationTime
        self.numberOfMajorCycles = numberOfMajorCycles
        self.numberOfInstrumentModels = numberOfInstrumentModels
        self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
        self.numberOfSkyImages = numberOfSkyImages
    def factory(*args_, **kwargs_):
        if ImagingPipeline.subclass:
            return ImagingPipeline.subclass(*args_, **kwargs_)
        else:
            return ImagingPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencyIntegrationStep(self): return self.frequencyIntegrationStep
    def set_frequencyIntegrationStep(self, frequencyIntegrationStep): self.frequencyIntegrationStep = frequencyIntegrationStep
    def get_timeIntegrationStep(self): return self.timeIntegrationStep
    def set_timeIntegrationStep(self, timeIntegrationStep): self.timeIntegrationStep = timeIntegrationStep
    def get_skyModelDatabase(self): return self.skyModelDatabase
    def set_skyModelDatabase(self, skyModelDatabase): self.skyModelDatabase = skyModelDatabase
    def get_demixing(self): return self.demixing
    def set_demixing(self, demixing): self.demixing = demixing
    def get_imagerIntegrationTime(self): return self.imagerIntegrationTime
    def set_imagerIntegrationTime(self, imagerIntegrationTime): self.imagerIntegrationTime = imagerIntegrationTime
    def get_numberOfMajorCycles(self): return self.numberOfMajorCycles
    def set_numberOfMajorCycles(self, numberOfMajorCycles): self.numberOfMajorCycles = numberOfMajorCycles
    def get_numberOfInstrumentModels(self): return self.numberOfInstrumentModels
    def set_numberOfInstrumentModels(self, numberOfInstrumentModels): self.numberOfInstrumentModels = numberOfInstrumentModels
    def get_numberOfCorrelatedDataProducts(self): return self.numberOfCorrelatedDataProducts
    def set_numberOfCorrelatedDataProducts(self, numberOfCorrelatedDataProducts): self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def get_numberOfSkyImages(self): return self.numberOfSkyImages
    def set_numberOfSkyImages(self, numberOfSkyImages): self.numberOfSkyImages = numberOfSkyImages
    def export(self, outfile, level, namespace_='', name_='ImagingPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImagingPipeline'):
        super(ImagingPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='ImagingPipeline', fromsubclass_=False, pretty_print=True):
        super(ImagingPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.frequencyIntegrationStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrequencyIntegrationStep>%s</%sfrequencyIntegrationStep>%s' % (namespace_, self.gds_format_integer(self.frequencyIntegrationStep, input_name='frequencyIntegrationStep'), namespace_, eol_))
        if self.timeIntegrationStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeIntegrationStep>%s</%stimeIntegrationStep>%s' % (namespace_, self.gds_format_integer(self.timeIntegrationStep, input_name='timeIntegrationStep'), namespace_, eol_))
        if self.skyModelDatabase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskyModelDatabase>%s</%sskyModelDatabase>%s' % (namespace_, self.gds_format_string(quote_xml(self.skyModelDatabase).encode(ExternalEncoding), input_name='skyModelDatabase'), namespace_, eol_))
        if self.demixing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdemixing>%s</%sdemixing>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.demixing)), input_name='demixing'), namespace_, eol_))
        if self.imagerIntegrationTime is not None:
            self.imagerIntegrationTime.export(outfile, level, namespace_, name_='imagerIntegrationTime', pretty_print=pretty_print)
        if self.numberOfMajorCycles is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfMajorCycles>%s</%snumberOfMajorCycles>%s' % (namespace_, self.gds_format_integer(self.numberOfMajorCycles, input_name='numberOfMajorCycles'), namespace_, eol_))
        if self.numberOfInstrumentModels is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfInstrumentModels>%s</%snumberOfInstrumentModels>%s' % (namespace_, self.gds_format_integer(self.numberOfInstrumentModels, input_name='numberOfInstrumentModels'), namespace_, eol_))
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCorrelatedDataProducts>%s</%snumberOfCorrelatedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfCorrelatedDataProducts, input_name='numberOfCorrelatedDataProducts'), namespace_, eol_))
        if self.numberOfSkyImages is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfSkyImages>%s</%snumberOfSkyImages>%s' % (namespace_, self.gds_format_integer(self.numberOfSkyImages, input_name='numberOfSkyImages'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.frequencyIntegrationStep is not None or
            self.timeIntegrationStep is not None or
            self.skyModelDatabase is not None or
            self.demixing is not None or
            self.imagerIntegrationTime is not None or
            self.numberOfMajorCycles is not None or
            self.numberOfInstrumentModels is not None or
            self.numberOfCorrelatedDataProducts is not None or
            self.numberOfSkyImages is not None or
            super(ImagingPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImagingPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ImagingPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ImagingPipeline, self).exportLiteralChildren(outfile, level, name_)
        if self.frequencyIntegrationStep is not None:
            showIndent(outfile, level)
            outfile.write('frequencyIntegrationStep=%d,\n' % self.frequencyIntegrationStep)
        if self.timeIntegrationStep is not None:
            showIndent(outfile, level)
            outfile.write('timeIntegrationStep=%d,\n' % self.timeIntegrationStep)
        if self.skyModelDatabase is not None:
            showIndent(outfile, level)
            outfile.write('skyModelDatabase=%s,\n' % quote_python(self.skyModelDatabase).encode(ExternalEncoding))
        if self.demixing is not None:
            showIndent(outfile, level)
            outfile.write('demixing=%s,\n' % self.demixing)
        if self.imagerIntegrationTime is not None:
            showIndent(outfile, level)
            outfile.write('imagerIntegrationTime=model_.Time(\n')
            self.imagerIntegrationTime.exportLiteral(outfile, level, name_='imagerIntegrationTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.numberOfMajorCycles is not None:
            showIndent(outfile, level)
            outfile.write('numberOfMajorCycles=%d,\n' % self.numberOfMajorCycles)
        if self.numberOfInstrumentModels is not None:
            showIndent(outfile, level)
            outfile.write('numberOfInstrumentModels=%d,\n' % self.numberOfInstrumentModels)
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCorrelatedDataProducts=%d,\n' % self.numberOfCorrelatedDataProducts)
        if self.numberOfSkyImages is not None:
            showIndent(outfile, level)
            outfile.write('numberOfSkyImages=%d,\n' % self.numberOfSkyImages)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ImagingPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frequencyIntegrationStep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'frequencyIntegrationStep')
            self.frequencyIntegrationStep = ival_
        elif nodeName_ == 'timeIntegrationStep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeIntegrationStep')
            self.timeIntegrationStep = ival_
        elif nodeName_ == 'skyModelDatabase':
            skyModelDatabase_ = child_.text
            skyModelDatabase_ = self.gds_validate_string(skyModelDatabase_, node, 'skyModelDatabase')
            self.skyModelDatabase = skyModelDatabase_
        elif nodeName_ == 'demixing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'demixing')
            self.demixing = ival_
        elif nodeName_ == 'imagerIntegrationTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_imagerIntegrationTime(obj_)
        elif nodeName_ == 'numberOfMajorCycles':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfMajorCycles')
            self.numberOfMajorCycles = ival_
        elif nodeName_ == 'numberOfInstrumentModels':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfInstrumentModels')
            self.numberOfInstrumentModels = ival_
        elif nodeName_ == 'numberOfCorrelatedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCorrelatedDataProducts')
            self.numberOfCorrelatedDataProducts = ival_
        elif nodeName_ == 'numberOfSkyImages':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfSkyImages')
            self.numberOfSkyImages = ival_
        super(ImagingPipeline, self).buildChildren(child_, node, nodeName_, True)
# end class ImagingPipeline


class CalibrationPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None, frequencyIntegrationStep=None, timeIntegrationStep=None, flagAutoCorrelations=None, demixing=None, skyModelDatabase=None, numberOfInstrumentModels=None, numberOfCorrelatedDataProducts=None):
        super(CalibrationPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        self.frequencyIntegrationStep = frequencyIntegrationStep
        self.timeIntegrationStep = timeIntegrationStep
        self.flagAutoCorrelations = flagAutoCorrelations
        self.demixing = demixing
        self.skyModelDatabase = skyModelDatabase
        self.numberOfInstrumentModels = numberOfInstrumentModels
        self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def factory(*args_, **kwargs_):
        if CalibrationPipeline.subclass:
            return CalibrationPipeline.subclass(*args_, **kwargs_)
        else:
            return CalibrationPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencyIntegrationStep(self): return self.frequencyIntegrationStep
    def set_frequencyIntegrationStep(self, frequencyIntegrationStep): self.frequencyIntegrationStep = frequencyIntegrationStep
    def get_timeIntegrationStep(self): return self.timeIntegrationStep
    def set_timeIntegrationStep(self, timeIntegrationStep): self.timeIntegrationStep = timeIntegrationStep
    def get_flagAutoCorrelations(self): return self.flagAutoCorrelations
    def set_flagAutoCorrelations(self, flagAutoCorrelations): self.flagAutoCorrelations = flagAutoCorrelations
    def get_demixing(self): return self.demixing
    def set_demixing(self, demixing): self.demixing = demixing
    def get_skyModelDatabase(self): return self.skyModelDatabase
    def set_skyModelDatabase(self, skyModelDatabase): self.skyModelDatabase = skyModelDatabase
    def get_numberOfInstrumentModels(self): return self.numberOfInstrumentModels
    def set_numberOfInstrumentModels(self, numberOfInstrumentModels): self.numberOfInstrumentModels = numberOfInstrumentModels
    def get_numberOfCorrelatedDataProducts(self): return self.numberOfCorrelatedDataProducts
    def set_numberOfCorrelatedDataProducts(self, numberOfCorrelatedDataProducts): self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def export(self, outfile, level, namespace_='', name_='CalibrationPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalibrationPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CalibrationPipeline'):
        super(CalibrationPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CalibrationPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='CalibrationPipeline', fromsubclass_=False, pretty_print=True):
        super(CalibrationPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.frequencyIntegrationStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrequencyIntegrationStep>%s</%sfrequencyIntegrationStep>%s' % (namespace_, self.gds_format_integer(self.frequencyIntegrationStep, input_name='frequencyIntegrationStep'), namespace_, eol_))
        if self.timeIntegrationStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeIntegrationStep>%s</%stimeIntegrationStep>%s' % (namespace_, self.gds_format_integer(self.timeIntegrationStep, input_name='timeIntegrationStep'), namespace_, eol_))
        if self.flagAutoCorrelations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflagAutoCorrelations>%s</%sflagAutoCorrelations>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.flagAutoCorrelations)), input_name='flagAutoCorrelations'), namespace_, eol_))
        if self.demixing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdemixing>%s</%sdemixing>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.demixing)), input_name='demixing'), namespace_, eol_))
        if self.skyModelDatabase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sskyModelDatabase>%s</%sskyModelDatabase>%s' % (namespace_, self.gds_format_string(quote_xml(self.skyModelDatabase).encode(ExternalEncoding), input_name='skyModelDatabase'), namespace_, eol_))
        if self.numberOfInstrumentModels is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfInstrumentModels>%s</%snumberOfInstrumentModels>%s' % (namespace_, self.gds_format_integer(self.numberOfInstrumentModels, input_name='numberOfInstrumentModels'), namespace_, eol_))
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCorrelatedDataProducts>%s</%snumberOfCorrelatedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfCorrelatedDataProducts, input_name='numberOfCorrelatedDataProducts'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.frequencyIntegrationStep is not None or
            self.timeIntegrationStep is not None or
            self.flagAutoCorrelations is not None or
            self.demixing is not None or
            self.skyModelDatabase is not None or
            self.numberOfInstrumentModels is not None or
            self.numberOfCorrelatedDataProducts is not None or
            super(CalibrationPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CalibrationPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CalibrationPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CalibrationPipeline, self).exportLiteralChildren(outfile, level, name_)
        if self.frequencyIntegrationStep is not None:
            showIndent(outfile, level)
            outfile.write('frequencyIntegrationStep=%d,\n' % self.frequencyIntegrationStep)
        if self.timeIntegrationStep is not None:
            showIndent(outfile, level)
            outfile.write('timeIntegrationStep=%d,\n' % self.timeIntegrationStep)
        if self.flagAutoCorrelations is not None:
            showIndent(outfile, level)
            outfile.write('flagAutoCorrelations=%s,\n' % self.flagAutoCorrelations)
        if self.demixing is not None:
            showIndent(outfile, level)
            outfile.write('demixing=%s,\n' % self.demixing)
        if self.skyModelDatabase is not None:
            showIndent(outfile, level)
            outfile.write('skyModelDatabase=%s,\n' % quote_python(self.skyModelDatabase).encode(ExternalEncoding))
        if self.numberOfInstrumentModels is not None:
            showIndent(outfile, level)
            outfile.write('numberOfInstrumentModels=%d,\n' % self.numberOfInstrumentModels)
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCorrelatedDataProducts=%d,\n' % self.numberOfCorrelatedDataProducts)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CalibrationPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frequencyIntegrationStep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'frequencyIntegrationStep')
            self.frequencyIntegrationStep = ival_
        elif nodeName_ == 'timeIntegrationStep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeIntegrationStep')
            self.timeIntegrationStep = ival_
        elif nodeName_ == 'flagAutoCorrelations':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'flagAutoCorrelations')
            self.flagAutoCorrelations = ival_
        elif nodeName_ == 'demixing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'demixing')
            self.demixing = ival_
        elif nodeName_ == 'skyModelDatabase':
            skyModelDatabase_ = child_.text
            skyModelDatabase_ = self.gds_validate_string(skyModelDatabase_, node, 'skyModelDatabase')
            self.skyModelDatabase = skyModelDatabase_
        elif nodeName_ == 'numberOfInstrumentModels':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfInstrumentModels')
            self.numberOfInstrumentModels = ival_
        elif nodeName_ == 'numberOfCorrelatedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCorrelatedDataProducts')
            self.numberOfCorrelatedDataProducts = ival_
        super(CalibrationPipeline, self).buildChildren(child_, node, nodeName_, True)
# end class CalibrationPipeline


class AveragingPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None, frequencyIntegrationStep=None, timeIntegrationStep=None, flagAutoCorrelations=None, demixing=None, numberOfCorrelatedDataProducts=None):
        super(AveragingPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        self.frequencyIntegrationStep = frequencyIntegrationStep
        self.timeIntegrationStep = timeIntegrationStep
        self.flagAutoCorrelations = flagAutoCorrelations
        self.demixing = demixing
        self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def factory(*args_, **kwargs_):
        if AveragingPipeline.subclass:
            return AveragingPipeline.subclass(*args_, **kwargs_)
        else:
            return AveragingPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencyIntegrationStep(self): return self.frequencyIntegrationStep
    def set_frequencyIntegrationStep(self, frequencyIntegrationStep): self.frequencyIntegrationStep = frequencyIntegrationStep
    def get_timeIntegrationStep(self): return self.timeIntegrationStep
    def set_timeIntegrationStep(self, timeIntegrationStep): self.timeIntegrationStep = timeIntegrationStep
    def get_flagAutoCorrelations(self): return self.flagAutoCorrelations
    def set_flagAutoCorrelations(self, flagAutoCorrelations): self.flagAutoCorrelations = flagAutoCorrelations
    def get_demixing(self): return self.demixing
    def set_demixing(self, demixing): self.demixing = demixing
    def get_numberOfCorrelatedDataProducts(self): return self.numberOfCorrelatedDataProducts
    def set_numberOfCorrelatedDataProducts(self, numberOfCorrelatedDataProducts): self.numberOfCorrelatedDataProducts = numberOfCorrelatedDataProducts
    def export(self, outfile, level, namespace_='', name_='AveragingPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AveragingPipeline'):
        super(AveragingPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AveragingPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='AveragingPipeline', fromsubclass_=False, pretty_print=True):
        super(AveragingPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.frequencyIntegrationStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrequencyIntegrationStep>%s</%sfrequencyIntegrationStep>%s' % (namespace_, self.gds_format_integer(self.frequencyIntegrationStep, input_name='frequencyIntegrationStep'), namespace_, eol_))
        if self.timeIntegrationStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeIntegrationStep>%s</%stimeIntegrationStep>%s' % (namespace_, self.gds_format_integer(self.timeIntegrationStep, input_name='timeIntegrationStep'), namespace_, eol_))
        if self.flagAutoCorrelations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflagAutoCorrelations>%s</%sflagAutoCorrelations>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.flagAutoCorrelations)), input_name='flagAutoCorrelations'), namespace_, eol_))
        if self.demixing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdemixing>%s</%sdemixing>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.demixing)), input_name='demixing'), namespace_, eol_))
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCorrelatedDataProducts>%s</%snumberOfCorrelatedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfCorrelatedDataProducts, input_name='numberOfCorrelatedDataProducts'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.frequencyIntegrationStep is not None or
            self.timeIntegrationStep is not None or
            self.flagAutoCorrelations is not None or
            self.demixing is not None or
            self.numberOfCorrelatedDataProducts is not None or
            super(AveragingPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AveragingPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AveragingPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AveragingPipeline, self).exportLiteralChildren(outfile, level, name_)
        if self.frequencyIntegrationStep is not None:
            showIndent(outfile, level)
            outfile.write('frequencyIntegrationStep=%d,\n' % self.frequencyIntegrationStep)
        if self.timeIntegrationStep is not None:
            showIndent(outfile, level)
            outfile.write('timeIntegrationStep=%d,\n' % self.timeIntegrationStep)
        if self.flagAutoCorrelations is not None:
            showIndent(outfile, level)
            outfile.write('flagAutoCorrelations=%s,\n' % self.flagAutoCorrelations)
        if self.demixing is not None:
            showIndent(outfile, level)
            outfile.write('demixing=%s,\n' % self.demixing)
        if self.numberOfCorrelatedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCorrelatedDataProducts=%d,\n' % self.numberOfCorrelatedDataProducts)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AveragingPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frequencyIntegrationStep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'frequencyIntegrationStep')
            self.frequencyIntegrationStep = ival_
        elif nodeName_ == 'timeIntegrationStep':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeIntegrationStep')
            self.timeIntegrationStep = ival_
        elif nodeName_ == 'flagAutoCorrelations':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'flagAutoCorrelations')
            self.flagAutoCorrelations = ival_
        elif nodeName_ == 'demixing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'demixing')
            self.demixing = ival_
        elif nodeName_ == 'numberOfCorrelatedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCorrelatedDataProducts')
            self.numberOfCorrelatedDataProducts = ival_
        super(AveragingPipeline, self).buildChildren(child_, node, nodeName_, True)
# end class AveragingPipeline


class KnownPulsarPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None, processedPulsar=None, knownPulsarStrategy=None, numberOfBeamFormedDataProducts=None):
        super(KnownPulsarPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        if processedPulsar is None:
            self.processedPulsar = []
        else:
            self.processedPulsar = processedPulsar
        self.knownPulsarStrategy = knownPulsarStrategy
        self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def factory(*args_, **kwargs_):
        if KnownPulsarPipeline.subclass:
            return KnownPulsarPipeline.subclass(*args_, **kwargs_)
        else:
            return KnownPulsarPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processedPulsar(self): return self.processedPulsar
    def set_processedPulsar(self, processedPulsar): self.processedPulsar = processedPulsar
    def add_processedPulsar(self, value): self.processedPulsar.append(value)
    def insert_processedPulsar(self, index, value): self.processedPulsar[index] = value
    def get_knownPulsarStrategy(self): return self.knownPulsarStrategy
    def set_knownPulsarStrategy(self, knownPulsarStrategy): self.knownPulsarStrategy = knownPulsarStrategy
    def get_numberOfBeamFormedDataProducts(self): return self.numberOfBeamFormedDataProducts
    def set_numberOfBeamFormedDataProducts(self, numberOfBeamFormedDataProducts): self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def export(self, outfile, level, namespace_='', name_='KnownPulsarPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KnownPulsarPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KnownPulsarPipeline'):
        super(KnownPulsarPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='KnownPulsarPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='KnownPulsarPipeline', fromsubclass_=False, pretty_print=True):
        super(KnownPulsarPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processedPulsar_ in self.processedPulsar:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessedPulsar>%s</%sprocessedPulsar>%s' % (namespace_, self.gds_format_string(quote_xml(processedPulsar_).encode(ExternalEncoding), input_name='processedPulsar'), namespace_, eol_))
        if self.knownPulsarStrategy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sknownPulsarStrategy>%s</%sknownPulsarStrategy>%s' % (namespace_, self.gds_format_string(quote_xml(self.knownPulsarStrategy).encode(ExternalEncoding), input_name='knownPulsarStrategy'), namespace_, eol_))
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBeamFormedDataProducts>%s</%snumberOfBeamFormedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfBeamFormedDataProducts, input_name='numberOfBeamFormedDataProducts'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.processedPulsar or
            self.knownPulsarStrategy is not None or
            self.numberOfBeamFormedDataProducts is not None or
            super(KnownPulsarPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KnownPulsarPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(KnownPulsarPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(KnownPulsarPipeline, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('processedPulsar=[\n')
        level += 1
        for processedPulsar_ in self.processedPulsar:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(processedPulsar_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.knownPulsarStrategy is not None:
            showIndent(outfile, level)
            outfile.write('knownPulsarStrategy=%s,\n' % quote_python(self.knownPulsarStrategy).encode(ExternalEncoding))
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfBeamFormedDataProducts=%d,\n' % self.numberOfBeamFormedDataProducts)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(KnownPulsarPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processedPulsar':
            processedPulsar_ = child_.text
            processedPulsar_ = self.gds_validate_string(processedPulsar_, node, 'processedPulsar')
            self.processedPulsar.append(processedPulsar_)
        elif nodeName_ == 'knownPulsarStrategy':
            knownPulsarStrategy_ = child_.text
            knownPulsarStrategy_ = self.gds_validate_string(knownPulsarStrategy_, node, 'knownPulsarStrategy')
            self.knownPulsarStrategy = knownPulsarStrategy_
        elif nodeName_ == 'numberOfBeamFormedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfBeamFormedDataProducts')
            self.numberOfBeamFormedDataProducts = ival_
        super(KnownPulsarPipeline, self).buildChildren(child_, node, nodeName_, True)
# end class KnownPulsarPipeline


class PulsarSearchPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None, processedPulsar=None, pulsarSearchStrategy=None, numberOfBeamFormedDataProducts=None):
        super(PulsarSearchPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        if processedPulsar is None:
            self.processedPulsar = []
        else:
            self.processedPulsar = processedPulsar
        self.pulsarSearchStrategy = pulsarSearchStrategy
        self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def factory(*args_, **kwargs_):
        if PulsarSearchPipeline.subclass:
            return PulsarSearchPipeline.subclass(*args_, **kwargs_)
        else:
            return PulsarSearchPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processedPulsar(self): return self.processedPulsar
    def set_processedPulsar(self, processedPulsar): self.processedPulsar = processedPulsar
    def add_processedPulsar(self, value): self.processedPulsar.append(value)
    def insert_processedPulsar(self, index, value): self.processedPulsar[index] = value
    def get_pulsarSearchStrategy(self): return self.pulsarSearchStrategy
    def set_pulsarSearchStrategy(self, pulsarSearchStrategy): self.pulsarSearchStrategy = pulsarSearchStrategy
    def get_numberOfBeamFormedDataProducts(self): return self.numberOfBeamFormedDataProducts
    def set_numberOfBeamFormedDataProducts(self, numberOfBeamFormedDataProducts): self.numberOfBeamFormedDataProducts = numberOfBeamFormedDataProducts
    def export(self, outfile, level, namespace_='', name_='PulsarSearchPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PulsarSearchPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PulsarSearchPipeline'):
        super(PulsarSearchPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PulsarSearchPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='PulsarSearchPipeline', fromsubclass_=False, pretty_print=True):
        super(PulsarSearchPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processedPulsar_ in self.processedPulsar:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocessedPulsar>%s</%sprocessedPulsar>%s' % (namespace_, self.gds_format_string(quote_xml(processedPulsar_).encode(ExternalEncoding), input_name='processedPulsar'), namespace_, eol_))
        if self.pulsarSearchStrategy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spulsarSearchStrategy>%s</%spulsarSearchStrategy>%s' % (namespace_, self.gds_format_string(quote_xml(self.pulsarSearchStrategy).encode(ExternalEncoding), input_name='pulsarSearchStrategy'), namespace_, eol_))
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBeamFormedDataProducts>%s</%snumberOfBeamFormedDataProducts>%s' % (namespace_, self.gds_format_integer(self.numberOfBeamFormedDataProducts, input_name='numberOfBeamFormedDataProducts'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.processedPulsar or
            self.pulsarSearchStrategy is not None or
            self.numberOfBeamFormedDataProducts is not None or
            super(PulsarSearchPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PulsarSearchPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PulsarSearchPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PulsarSearchPipeline, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('processedPulsar=[\n')
        level += 1
        for processedPulsar_ in self.processedPulsar:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(processedPulsar_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.pulsarSearchStrategy is not None:
            showIndent(outfile, level)
            outfile.write('pulsarSearchStrategy=%s,\n' % quote_python(self.pulsarSearchStrategy).encode(ExternalEncoding))
        if self.numberOfBeamFormedDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('numberOfBeamFormedDataProducts=%d,\n' % self.numberOfBeamFormedDataProducts)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PulsarSearchPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processedPulsar':
            processedPulsar_ = child_.text
            processedPulsar_ = self.gds_validate_string(processedPulsar_, node, 'processedPulsar')
            self.processedPulsar.append(processedPulsar_)
        elif nodeName_ == 'pulsarSearchStrategy':
            pulsarSearchStrategy_ = child_.text
            pulsarSearchStrategy_ = self.gds_validate_string(pulsarSearchStrategy_, node, 'pulsarSearchStrategy')
            self.pulsarSearchStrategy = pulsarSearchStrategy_
        elif nodeName_ == 'numberOfBeamFormedDataProducts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfBeamFormedDataProducts')
            self.numberOfBeamFormedDataProducts = ival_
        super(PulsarSearchPipeline, self).buildChildren(child_, node, nodeName_, True)
# end class PulsarSearchPipeline


class CosmicRayPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None):
        super(CosmicRayPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        pass
    def factory(*args_, **kwargs_):
        if CosmicRayPipeline.subclass:
            return CosmicRayPipeline.subclass(*args_, **kwargs_)
        else:
            return CosmicRayPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CosmicRayPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CosmicRayPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CosmicRayPipeline'):
        super(CosmicRayPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CosmicRayPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='CosmicRayPipeline', fromsubclass_=False, pretty_print=True):
        super(CosmicRayPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(CosmicRayPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CosmicRayPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CosmicRayPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CosmicRayPipeline, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CosmicRayPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CosmicRayPipeline, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CosmicRayPipeline


class GenericPipeline(PipelineRun):
    subclass = None
    superclass = PipelineRun
    def __init__(self, processIdentifier=None, observationId=None, parset=None, strategyName=None, strategyDescription=None, startTime=None, duration=None, pipelineName=None, pipelineVersion=None, sourceData=None):
        super(GenericPipeline, self).__init__(processIdentifier, observationId, parset, strategyName, strategyDescription, startTime, duration, pipelineName, pipelineVersion, sourceData, )
        pass
    def factory(*args_, **kwargs_):
        if GenericPipeline.subclass:
            return GenericPipeline.subclass(*args_, **kwargs_)
        else:
            return GenericPipeline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='GenericPipeline', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericPipeline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericPipeline'):
        super(GenericPipeline, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GenericPipeline')
    def exportChildren(self, outfile, level, namespace_='', name_='GenericPipeline', fromsubclass_=False, pretty_print=True):
        super(GenericPipeline, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(GenericPipeline, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GenericPipeline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GenericPipeline, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GenericPipeline, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericPipeline, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericPipeline, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericPipeline


class ChecksumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, algorithm=None, value=None):
        self.algorithm = algorithm
        self.value = value
    def factory(*args_, **kwargs_):
        if ChecksumType.subclass:
            return ChecksumType.subclass(*args_, **kwargs_)
        else:
            return ChecksumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def validate_ChecksumAlgorithm(self, value):
        # Validate type ChecksumAlgorithm, a restriction on xs:string.
        pass
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='ChecksumType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChecksumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChecksumType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChecksumType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.algorithm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salgorithm>%s</%salgorithm>%s' % (namespace_, self.gds_format_string(quote_xml(self.algorithm).encode(ExternalEncoding), input_name='algorithm'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.algorithm is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChecksumType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.algorithm is not None:
            showIndent(outfile, level)
            outfile.write('algorithm=%s,\n' % quote_python(self.algorithm).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'algorithm':
            algorithm_ = child_.text
            algorithm_ = self.gds_validate_string(algorithm_, node, 'algorithm')
            self.algorithm = algorithm_
            self.validate_ChecksumAlgorithm(self.algorithm)    # validate type ChecksumAlgorithm
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class ChecksumType


class TBBTrigger(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.type_ = type_
        self.value = value
    def factory(*args_, **kwargs_):
        if TBBTrigger.subclass:
            return TBBTrigger.subclass(*args_, **kwargs_)
        else:
            return TBBTrigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='TBBTrigger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TBBTrigger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TBBTrigger'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TBBTrigger', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TBBTrigger'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class TBBTrigger


class DataProduct(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, extensiontype_=None):
        self.dataProductType = dataProductType
        self.dataProductIdentifier = dataProductIdentifier
        self.storageTicket = storageTicket
        self.size = size
        if checksum is None:
            self.checksum = []
        else:
            self.checksum = checksum
        self.fileName = fileName
        self.fileFormat = fileFormat
        self.processIdentifier = processIdentifier
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DataProduct.subclass:
            return DataProduct.subclass(*args_, **kwargs_)
        else:
            return DataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataProductType(self): return self.dataProductType
    def set_dataProductType(self, dataProductType): self.dataProductType = dataProductType
    def validate_DataProductType(self, value):
        # Validate type DataProductType, a restriction on xs:string.
        pass
    def get_dataProductIdentifier(self): return self.dataProductIdentifier
    def set_dataProductIdentifier(self, dataProductIdentifier): self.dataProductIdentifier = dataProductIdentifier
    def get_storageTicket(self): return self.storageTicket
    def set_storageTicket(self, storageTicket): self.storageTicket = storageTicket
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_checksum(self): return self.checksum
    def set_checksum(self, checksum): self.checksum = checksum
    def add_checksum(self, value): self.checksum.append(value)
    def insert_checksum(self, index, value): self.checksum[index] = value
    def get_fileName(self): return self.fileName
    def set_fileName(self, fileName): self.fileName = fileName
    def get_fileFormat(self): return self.fileFormat
    def set_fileFormat(self, fileFormat): self.fileFormat = fileFormat
    def validate_FileFormatType(self, value):
        # Validate type FileFormatType, a restriction on xs:string.
        pass
    def get_processIdentifier(self): return self.processIdentifier
    def set_processIdentifier(self, processIdentifier): self.processIdentifier = processIdentifier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataProduct'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dataProductType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataProductType>%s</%sdataProductType>%s' % (namespace_, self.gds_format_string(quote_xml(self.dataProductType).encode(ExternalEncoding), input_name='dataProductType'), namespace_, eol_))
        if self.dataProductIdentifier is not None:
            self.dataProductIdentifier.export(outfile, level, namespace_, name_='dataProductIdentifier', pretty_print=pretty_print)
        if self.storageTicket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorageTicket>%s</%sstorageTicket>%s' % (namespace_, self.gds_format_string(quote_xml(self.storageTicket).encode(ExternalEncoding), input_name='storageTicket'), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        for checksum_ in self.checksum:
            checksum_.export(outfile, level, namespace_, name_='checksum', pretty_print=pretty_print)
        if self.fileName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileName>%s</%sfileName>%s' % (namespace_, self.gds_format_string(quote_xml(self.fileName).encode(ExternalEncoding), input_name='fileName'), namespace_, eol_))
        if self.fileFormat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileFormat>%s</%sfileFormat>%s' % (namespace_, self.gds_format_string(quote_xml(self.fileFormat).encode(ExternalEncoding), input_name='fileFormat'), namespace_, eol_))
        if self.processIdentifier is not None:
            self.processIdentifier.export(outfile, level, namespace_, name_='processIdentifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.dataProductType is not None or
            self.dataProductIdentifier is not None or
            self.storageTicket is not None or
            self.size is not None or
            self.checksum or
            self.fileName is not None or
            self.fileFormat is not None or
            self.processIdentifier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dataProductType is not None:
            showIndent(outfile, level)
            outfile.write('dataProductType=%s,\n' % quote_python(self.dataProductType).encode(ExternalEncoding))
        if self.dataProductIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('dataProductIdentifier=model_.IdentifierType(\n')
            self.dataProductIdentifier.exportLiteral(outfile, level, name_='dataProductIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.storageTicket is not None:
            showIndent(outfile, level)
            outfile.write('storageTicket=%s,\n' % quote_python(self.storageTicket).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        showIndent(outfile, level)
        outfile.write('checksum=[\n')
        level += 1
        for checksum_ in self.checksum:
            showIndent(outfile, level)
            outfile.write('model_.ChecksumType(\n')
            checksum_.exportLiteral(outfile, level, name_='ChecksumType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.fileName is not None:
            showIndent(outfile, level)
            outfile.write('fileName=%s,\n' % quote_python(self.fileName).encode(ExternalEncoding))
        if self.fileFormat is not None:
            showIndent(outfile, level)
            outfile.write('fileFormat=%s,\n' % quote_python(self.fileFormat).encode(ExternalEncoding))
        if self.processIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('processIdentifier=model_.IdentifierType(\n')
            self.processIdentifier.exportLiteral(outfile, level, name_='processIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataProductType':
            dataProductType_ = child_.text
            dataProductType_ = self.gds_validate_string(dataProductType_, node, 'dataProductType')
            self.dataProductType = dataProductType_
            self.validate_DataProductType(self.dataProductType)    # validate type DataProductType
        elif nodeName_ == 'dataProductIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_dataProductIdentifier(obj_)
        elif nodeName_ == 'storageTicket':
            storageTicket_ = child_.text
            storageTicket_ = self.gds_validate_string(storageTicket_, node, 'storageTicket')
            self.storageTicket = storageTicket_
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'checksum':
            obj_ = ChecksumType.factory()
            obj_.build(child_)
            self.checksum.append(obj_)
        elif nodeName_ == 'fileName':
            fileName_ = child_.text
            fileName_ = self.gds_validate_string(fileName_, node, 'fileName')
            self.fileName = fileName_
        elif nodeName_ == 'fileFormat':
            fileFormat_ = child_.text
            fileFormat_ = self.gds_validate_string(fileFormat_, node, 'fileFormat')
            self.fileFormat = fileFormat_
            self.validate_FileFormatType(self.fileFormat)    # validate type FileFormatType
        elif nodeName_ == 'processIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_processIdentifier(obj_)
# end class DataProduct


class CorrelatedDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, subArrayPointingIdentifier=None, subband=None, stationSubband=None, startTime=None, duration=None, integrationInterval=None, centralFrequency=None, channelWidth=None, channelsPerSubband=None):
        super(CorrelatedDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        self.subArrayPointingIdentifier = subArrayPointingIdentifier
        self.subband = subband
        self.stationSubband = stationSubband
        self.startTime = startTime
        self.duration = duration
        self.integrationInterval = integrationInterval
        self.centralFrequency = centralFrequency
        self.channelWidth = channelWidth
        self.channelsPerSubband = channelsPerSubband
    def factory(*args_, **kwargs_):
        if CorrelatedDataProduct.subclass:
            return CorrelatedDataProduct.subclass(*args_, **kwargs_)
        else:
            return CorrelatedDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subArrayPointingIdentifier(self): return self.subArrayPointingIdentifier
    def set_subArrayPointingIdentifier(self, subArrayPointingIdentifier): self.subArrayPointingIdentifier = subArrayPointingIdentifier
    def get_subband(self): return self.subband
    def set_subband(self, subband): self.subband = subband
    def get_stationSubband(self): return self.stationSubband
    def set_stationSubband(self, stationSubband): self.stationSubband = stationSubband
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_integrationInterval(self): return self.integrationInterval
    def set_integrationInterval(self, integrationInterval): self.integrationInterval = integrationInterval
    def get_centralFrequency(self): return self.centralFrequency
    def set_centralFrequency(self, centralFrequency): self.centralFrequency = centralFrequency
    def get_channelWidth(self): return self.channelWidth
    def set_channelWidth(self, channelWidth): self.channelWidth = channelWidth
    def get_channelsPerSubband(self): return self.channelsPerSubband
    def set_channelsPerSubband(self, channelsPerSubband): self.channelsPerSubband = channelsPerSubband
    def export(self, outfile, level, namespace_='', name_='CorrelatedDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrelatedDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrelatedDataProduct'):
        super(CorrelatedDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CorrelatedDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='CorrelatedDataProduct', fromsubclass_=False, pretty_print=True):
        super(CorrelatedDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subArrayPointingIdentifier is not None:
            self.subArrayPointingIdentifier.export(outfile, level, namespace_, name_='subArrayPointingIdentifier', pretty_print=pretty_print)
        if self.subband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubband>%s</%ssubband>%s' % (namespace_, self.gds_format_integer(self.subband, input_name='subband'), namespace_, eol_))
        if self.stationSubband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstationSubband>%s</%sstationSubband>%s' % (namespace_, self.gds_format_integer(self.stationSubband, input_name='stationSubband'), namespace_, eol_))
        if self.startTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartTime>%s</%sstartTime>%s' % (namespace_, self.gds_format_datetime(self.startTime, input_name='startTime'), namespace_, eol_))
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespace_, self.gds_format_string(quote_xml(self.duration).encode(ExternalEncoding), input_name='duration'), namespace_, eol_))
        if self.integrationInterval is not None:
            self.integrationInterval.export(outfile, level, namespace_, name_='integrationInterval', pretty_print=pretty_print)
        if self.centralFrequency is not None:
            self.centralFrequency.export(outfile, level, namespace_, name_='centralFrequency', pretty_print=pretty_print)
        if self.channelWidth is not None:
            self.channelWidth.export(outfile, level, namespace_, name_='channelWidth', pretty_print=pretty_print)
        if self.channelsPerSubband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schannelsPerSubband>%s</%schannelsPerSubband>%s' % (namespace_, self.gds_format_integer(self.channelsPerSubband, input_name='channelsPerSubband'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.subArrayPointingIdentifier is not None or
            self.subband is not None or
            self.stationSubband is not None or
            self.startTime is not None or
            self.duration is not None or
            self.integrationInterval is not None or
            self.centralFrequency is not None or
            self.channelWidth is not None or
            self.channelsPerSubband is not None or
            super(CorrelatedDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CorrelatedDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CorrelatedDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CorrelatedDataProduct, self).exportLiteralChildren(outfile, level, name_)
        if self.subArrayPointingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('subArrayPointingIdentifier=model_.IdentifierType(\n')
            self.subArrayPointingIdentifier.exportLiteral(outfile, level, name_='subArrayPointingIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subband is not None:
            showIndent(outfile, level)
            outfile.write('subband=%d,\n' % self.subband)
        if self.stationSubband is not None:
            showIndent(outfile, level)
            outfile.write('stationSubband=%d,\n' % self.stationSubband)
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=datetime_.strptime("%s", "%%Y-%%m-%%dT%%H:%%M:%%S"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=%s,\n' % quote_python(self.duration).encode(ExternalEncoding))
        if self.integrationInterval is not None:
            showIndent(outfile, level)
            outfile.write('integrationInterval=model_.Time(\n')
            self.integrationInterval.exportLiteral(outfile, level, name_='integrationInterval')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.centralFrequency is not None:
            showIndent(outfile, level)
            outfile.write('centralFrequency=model_.Frequency(\n')
            self.centralFrequency.exportLiteral(outfile, level, name_='centralFrequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.channelWidth is not None:
            showIndent(outfile, level)
            outfile.write('channelWidth=model_.Frequency(\n')
            self.channelWidth.exportLiteral(outfile, level, name_='channelWidth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.channelsPerSubband is not None:
            showIndent(outfile, level)
            outfile.write('channelsPerSubband=%d,\n' % self.channelsPerSubband)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CorrelatedDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subArrayPointingIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_subArrayPointingIdentifier(obj_)
        elif nodeName_ == 'subband':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subband')
            self.subband = ival_
        elif nodeName_ == 'stationSubband':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'stationSubband')
            self.stationSubband = ival_
        elif nodeName_ == 'startTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_, node, 'startTime')
            self.startTime = dval_
        elif nodeName_ == 'duration':
            duration_ = child_.text
            duration_ = self.gds_validate_string(duration_, node, 'duration')
            self.duration = duration_
        elif nodeName_ == 'integrationInterval':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_integrationInterval(obj_)
        elif nodeName_ == 'centralFrequency':
            class_obj_ = self.get_class_obj_(child_, Frequency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_centralFrequency(obj_)
        elif nodeName_ == 'channelWidth':
            class_obj_ = self.get_class_obj_(child_, Frequency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_channelWidth(obj_)
        elif nodeName_ == 'channelsPerSubband':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'channelsPerSubband')
            self.channelsPerSubband = ival_
        super(CorrelatedDataProduct, self).buildChildren(child_, node, nodeName_, True)
# end class CorrelatedDataProduct


class InstrumentModelDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None):
        super(InstrumentModelDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        pass
    def factory(*args_, **kwargs_):
        if InstrumentModelDataProduct.subclass:
            return InstrumentModelDataProduct.subclass(*args_, **kwargs_)
        else:
            return InstrumentModelDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='InstrumentModelDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentModelDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstrumentModelDataProduct'):
        super(InstrumentModelDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstrumentModelDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='InstrumentModelDataProduct', fromsubclass_=False, pretty_print=True):
        super(InstrumentModelDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(InstrumentModelDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InstrumentModelDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstrumentModelDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstrumentModelDataProduct, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(InstrumentModelDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstrumentModelDataProduct, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstrumentModelDataProduct


class SkyModelDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None):
        super(SkyModelDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        pass
    def factory(*args_, **kwargs_):
        if SkyModelDataProduct.subclass:
            return SkyModelDataProduct.subclass(*args_, **kwargs_)
        else:
            return SkyModelDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SkyModelDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SkyModelDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SkyModelDataProduct'):
        super(SkyModelDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SkyModelDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='SkyModelDataProduct', fromsubclass_=False, pretty_print=True):
        super(SkyModelDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(SkyModelDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SkyModelDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SkyModelDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SkyModelDataProduct, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SkyModelDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SkyModelDataProduct, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SkyModelDataProduct


class TransientBufferBoardDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, numberOfSamples=None, timeStamp=None, triggerParameters=None):
        super(TransientBufferBoardDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        self.numberOfSamples = numberOfSamples
        self.timeStamp = timeStamp
        self.triggerParameters = triggerParameters
    def factory(*args_, **kwargs_):
        if TransientBufferBoardDataProduct.subclass:
            return TransientBufferBoardDataProduct.subclass(*args_, **kwargs_)
        else:
            return TransientBufferBoardDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfSamples(self): return self.numberOfSamples
    def set_numberOfSamples(self, numberOfSamples): self.numberOfSamples = numberOfSamples
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_triggerParameters(self): return self.triggerParameters
    def set_triggerParameters(self, triggerParameters): self.triggerParameters = triggerParameters
    def export(self, outfile, level, namespace_='', name_='TransientBufferBoardDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransientBufferBoardDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransientBufferBoardDataProduct'):
        super(TransientBufferBoardDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TransientBufferBoardDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='TransientBufferBoardDataProduct', fromsubclass_=False, pretty_print=True):
        super(TransientBufferBoardDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberOfSamples is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfSamples>%s</%snumberOfSamples>%s' % (namespace_, self.gds_format_integer(self.numberOfSamples, input_name='numberOfSamples'), namespace_, eol_))
        if self.timeStamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeStamp>%s</%stimeStamp>%s' % (namespace_, self.gds_format_integer(self.timeStamp, input_name='timeStamp'), namespace_, eol_))
        if self.triggerParameters is not None:
            self.triggerParameters.export(outfile, level, namespace_, name_='triggerParameters', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.numberOfSamples is not None or
            self.timeStamp is not None or
            self.triggerParameters is not None or
            super(TransientBufferBoardDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransientBufferBoardDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TransientBufferBoardDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TransientBufferBoardDataProduct, self).exportLiteralChildren(outfile, level, name_)
        if self.numberOfSamples is not None:
            showIndent(outfile, level)
            outfile.write('numberOfSamples=%d,\n' % self.numberOfSamples)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('timeStamp=%d,\n' % self.timeStamp)
        if self.triggerParameters is not None:
            showIndent(outfile, level)
            outfile.write('triggerParameters=model_.TBBTrigger(\n')
            self.triggerParameters.exportLiteral(outfile, level, name_='triggerParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TransientBufferBoardDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfSamples':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfSamples')
            self.numberOfSamples = ival_
        elif nodeName_ == 'timeStamp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeStamp')
            self.timeStamp = ival_
        elif nodeName_ == 'triggerParameters':
            obj_ = TBBTrigger.factory()
            obj_.build(child_)
            self.set_triggerParameters(obj_)
        super(TransientBufferBoardDataProduct, self).buildChildren(child_, node, nodeName_, True)
# end class TransientBufferBoardDataProduct


class ArrayBeams(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, arrayBeam=None):
        if arrayBeam is None:
            self.arrayBeam = []
        else:
            self.arrayBeam = arrayBeam
    def factory(*args_, **kwargs_):
        if ArrayBeams.subclass:
            return ArrayBeams.subclass(*args_, **kwargs_)
        else:
            return ArrayBeams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arrayBeam(self): return self.arrayBeam
    def set_arrayBeam(self, arrayBeam): self.arrayBeam = arrayBeam
    def add_arrayBeam(self, value): self.arrayBeam.append(value)
    def insert_arrayBeam(self, index, value): self.arrayBeam[index] = value
    def export(self, outfile, level, namespace_='', name_='ArrayBeams', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayBeams')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrayBeams'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArrayBeams', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for arrayBeam_ in self.arrayBeam:
            arrayBeam_.export(outfile, level, namespace_, name_='arrayBeam', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.arrayBeam
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArrayBeams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('arrayBeam=[\n')
        level += 1
        for arrayBeam_ in self.arrayBeam:
            showIndent(outfile, level)
            outfile.write('model_.ArrayBeam(\n')
            arrayBeam_.exportLiteral(outfile, level, name_='ArrayBeam')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'arrayBeam':
            class_obj_ = self.get_class_obj_(child_, ArrayBeam)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.arrayBeam.append(obj_)
# end class ArrayBeams


class ArrayBeam(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subArrayPointingIdentifier=None, beamNumber=None, dispersionMeasure=None, numberOfSubbands=None, stationSubbands=None, samplingTime=None, centralFrequencies=None, channelWidth=None, channelsPerSubband=None, stokes=None, extensiontype_=None):
        self.subArrayPointingIdentifier = subArrayPointingIdentifier
        self.beamNumber = beamNumber
        self.dispersionMeasure = dispersionMeasure
        self.numberOfSubbands = numberOfSubbands
        self.stationSubbands = stationSubbands
        self.samplingTime = samplingTime
        self.centralFrequencies = centralFrequencies
        self.channelWidth = channelWidth
        self.channelsPerSubband = channelsPerSubband
        if stokes is None:
            self.stokes = []
        else:
            self.stokes = stokes
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ArrayBeam.subclass:
            return ArrayBeam.subclass(*args_, **kwargs_)
        else:
            return ArrayBeam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subArrayPointingIdentifier(self): return self.subArrayPointingIdentifier
    def set_subArrayPointingIdentifier(self, subArrayPointingIdentifier): self.subArrayPointingIdentifier = subArrayPointingIdentifier
    def get_beamNumber(self): return self.beamNumber
    def set_beamNumber(self, beamNumber): self.beamNumber = beamNumber
    def get_dispersionMeasure(self): return self.dispersionMeasure
    def set_dispersionMeasure(self, dispersionMeasure): self.dispersionMeasure = dispersionMeasure
    def get_numberOfSubbands(self): return self.numberOfSubbands
    def set_numberOfSubbands(self, numberOfSubbands): self.numberOfSubbands = numberOfSubbands
    def get_stationSubbands(self): return self.stationSubbands
    def set_stationSubbands(self, stationSubbands): self.stationSubbands = stationSubbands
    def validate_ListOfSubbands(self, value):
        # Validate type ListOfSubbands, a restriction on xs:unsignedShort.
        pass
    def get_samplingTime(self): return self.samplingTime
    def set_samplingTime(self, samplingTime): self.samplingTime = samplingTime
    def get_centralFrequencies(self): return self.centralFrequencies
    def set_centralFrequencies(self, centralFrequencies): self.centralFrequencies = centralFrequencies
    def get_channelWidth(self): return self.channelWidth
    def set_channelWidth(self, channelWidth): self.channelWidth = channelWidth
    def get_channelsPerSubband(self): return self.channelsPerSubband
    def set_channelsPerSubband(self, channelsPerSubband): self.channelsPerSubband = channelsPerSubband
    def get_stokes(self): return self.stokes
    def set_stokes(self, stokes): self.stokes = stokes
    def add_stokes(self, value): self.stokes.append(value)
    def insert_stokes(self, index, value): self.stokes[index] = value
    def validate_PolarizationType(self, value):
        # Validate type PolarizationType, a restriction on xs:string.
        pass
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ArrayBeam', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayBeam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrayBeam'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArrayBeam', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subArrayPointingIdentifier is not None:
            self.subArrayPointingIdentifier.export(outfile, level, namespace_, name_='subArrayPointingIdentifier', pretty_print=pretty_print)
        if self.beamNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeamNumber>%s</%sbeamNumber>%s' % (namespace_, self.gds_format_integer(self.beamNumber, input_name='beamNumber'), namespace_, eol_))
        if self.dispersionMeasure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdispersionMeasure>%s</%sdispersionMeasure>%s' % (namespace_, self.gds_format_double(self.dispersionMeasure, input_name='dispersionMeasure'), namespace_, eol_))
        if self.numberOfSubbands is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfSubbands>%s</%snumberOfSubbands>%s' % (namespace_, self.gds_format_integer(self.numberOfSubbands, input_name='numberOfSubbands'), namespace_, eol_))
        if self.stationSubbands is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstationSubbands>%s</%sstationSubbands>%s' % (namespace_, self.gds_format_integer_list(self.stationSubbands, input_name='stationSubbands'), namespace_, eol_))
        if self.samplingTime is not None:
            self.samplingTime.export(outfile, level, namespace_, name_='samplingTime', pretty_print=pretty_print)
        if self.centralFrequencies is not None:
            self.centralFrequencies.export(outfile, level, namespace_, name_='centralFrequencies', pretty_print=pretty_print)
        if self.channelWidth is not None:
            self.channelWidth.export(outfile, level, namespace_, name_='channelWidth', pretty_print=pretty_print)
        if self.channelsPerSubband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schannelsPerSubband>%s</%schannelsPerSubband>%s' % (namespace_, self.gds_format_integer(self.channelsPerSubband, input_name='channelsPerSubband'), namespace_, eol_))
        for stokes_ in self.stokes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstokes>%s</%sstokes>%s' % (namespace_, self.gds_format_string(quote_xml(stokes_).encode(ExternalEncoding), input_name='stokes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.subArrayPointingIdentifier is not None or
            self.beamNumber is not None or
            self.dispersionMeasure is not None or
            self.numberOfSubbands is not None or
            self.stationSubbands is not None or
            self.samplingTime is not None or
            self.centralFrequencies is not None or
            self.channelWidth is not None or
            self.channelsPerSubband is not None or
            self.stokes
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArrayBeam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.subArrayPointingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('subArrayPointingIdentifier=model_.IdentifierType(\n')
            self.subArrayPointingIdentifier.exportLiteral(outfile, level, name_='subArrayPointingIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.beamNumber is not None:
            showIndent(outfile, level)
            outfile.write('beamNumber=%d,\n' % self.beamNumber)
        if self.dispersionMeasure is not None:
            showIndent(outfile, level)
            outfile.write('dispersionMeasure=%e,\n' % self.dispersionMeasure)
        if self.numberOfSubbands is not None:
            showIndent(outfile, level)
            outfile.write('numberOfSubbands=%d,\n' % self.numberOfSubbands)
        if self.stationSubbands is not None:
            showIndent(outfile, level)
            outfile.write('stationSubbands=%d,\n' % self.stationSubbands)
        if self.samplingTime is not None:
            showIndent(outfile, level)
            outfile.write('samplingTime=model_.Time(\n')
            self.samplingTime.exportLiteral(outfile, level, name_='samplingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.centralFrequencies is not None:
            showIndent(outfile, level)
            outfile.write('centralFrequencies=model_.ListOfFrequencies(\n')
            self.centralFrequencies.exportLiteral(outfile, level, name_='centralFrequencies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.channelWidth is not None:
            showIndent(outfile, level)
            outfile.write('channelWidth=model_.Frequency(\n')
            self.channelWidth.exportLiteral(outfile, level, name_='channelWidth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.channelsPerSubband is not None:
            showIndent(outfile, level)
            outfile.write('channelsPerSubband=%d,\n' % self.channelsPerSubband)
        showIndent(outfile, level)
        outfile.write('stokes=[\n')
        level += 1
        for stokes_ in self.stokes:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stokes_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subArrayPointingIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_subArrayPointingIdentifier(obj_)
        elif nodeName_ == 'beamNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beamNumber')
            self.beamNumber = ival_
        elif nodeName_ == 'dispersionMeasure':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'dispersionMeasure')
            self.dispersionMeasure = fval_
        elif nodeName_ == 'numberOfSubbands':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfSubbands')
            self.numberOfSubbands = ival_
        elif nodeName_ == 'stationSubbands':
            stationSubbands_ = child_.text
            stationSubbands_ = self.gds_validate_integer_list(stationSubbands_, node, 'stationSubbands')
            self.stationSubbands = stationSubbands_
            self.stationSubbands = self.stationSubbands.split()
            self.validate_ListOfSubbands(self.stationSubbands)    # validate type ListOfSubbands
        elif nodeName_ == 'samplingTime':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_samplingTime(obj_)
        elif nodeName_ == 'centralFrequencies':
            obj_ = ListOfFrequencies.factory()
            obj_.build(child_)
            self.set_centralFrequencies(obj_)
        elif nodeName_ == 'channelWidth':
            class_obj_ = self.get_class_obj_(child_, Frequency)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_channelWidth(obj_)
        elif nodeName_ == 'channelsPerSubband':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'channelsPerSubband')
            self.channelsPerSubband = ival_
        elif nodeName_ == 'stokes':
            stokes_ = child_.text
            stokes_ = self.gds_validate_string(stokes_, node, 'stokes')
            self.stokes.append(stokes_)
            self.validate_PolarizationType(self.stokes)    # validate type PolarizationType
# end class ArrayBeam


class CoherentStokesBeam(ArrayBeam):
    subclass = None
    superclass = ArrayBeam
    def __init__(self, subArrayPointingIdentifier=None, beamNumber=None, dispersionMeasure=None, numberOfSubbands=None, stationSubbands=None, samplingTime=None, centralFrequencies=None, channelWidth=None, channelsPerSubband=None, stokes=None, pointing=None, offset=None):
        super(CoherentStokesBeam, self).__init__(subArrayPointingIdentifier, beamNumber, dispersionMeasure, numberOfSubbands, stationSubbands, samplingTime, centralFrequencies, channelWidth, channelsPerSubband, stokes, )
        self.pointing = pointing
        self.offset = offset
    def factory(*args_, **kwargs_):
        if CoherentStokesBeam.subclass:
            return CoherentStokesBeam.subclass(*args_, **kwargs_)
        else:
            return CoherentStokesBeam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pointing(self): return self.pointing
    def set_pointing(self, pointing): self.pointing = pointing
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def export(self, outfile, level, namespace_='', name_='CoherentStokesBeam', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoherentStokesBeam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoherentStokesBeam'):
        super(CoherentStokesBeam, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoherentStokesBeam')
    def exportChildren(self, outfile, level, namespace_='', name_='CoherentStokesBeam', fromsubclass_=False, pretty_print=True):
        super(CoherentStokesBeam, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pointing is not None:
            self.pointing.export(outfile, level, namespace_, name_='pointing', pretty_print=pretty_print)
        if self.offset is not None:
            self.offset.export(outfile, level, namespace_, name_='offset', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.pointing is not None or
            self.offset is not None or
            super(CoherentStokesBeam, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CoherentStokesBeam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CoherentStokesBeam, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CoherentStokesBeam, self).exportLiteralChildren(outfile, level, name_)
        if self.pointing is not None:
            showIndent(outfile, level)
            outfile.write('pointing=model_.Pointing(\n')
            self.pointing.exportLiteral(outfile, level, name_='pointing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.offset is not None:
            showIndent(outfile, level)
            outfile.write('offset=model_.Pointing(\n')
            self.offset.exportLiteral(outfile, level, name_='offset')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CoherentStokesBeam, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pointing':
            obj_ = Pointing.factory()
            obj_.build(child_)
            self.set_pointing(obj_)
        elif nodeName_ == 'offset':
            obj_ = Pointing.factory()
            obj_.build(child_)
            self.set_offset(obj_)
        super(CoherentStokesBeam, self).buildChildren(child_, node, nodeName_, True)
# end class CoherentStokesBeam


class IncoherentStokesBeam(ArrayBeam):
    subclass = None
    superclass = ArrayBeam
    def __init__(self, subArrayPointingIdentifier=None, beamNumber=None, dispersionMeasure=None, numberOfSubbands=None, stationSubbands=None, samplingTime=None, centralFrequencies=None, channelWidth=None, channelsPerSubband=None, stokes=None):
        super(IncoherentStokesBeam, self).__init__(subArrayPointingIdentifier, beamNumber, dispersionMeasure, numberOfSubbands, stationSubbands, samplingTime, centralFrequencies, channelWidth, channelsPerSubband, stokes, )
        pass
    def factory(*args_, **kwargs_):
        if IncoherentStokesBeam.subclass:
            return IncoherentStokesBeam.subclass(*args_, **kwargs_)
        else:
            return IncoherentStokesBeam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='IncoherentStokesBeam', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncoherentStokesBeam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IncoherentStokesBeam'):
        super(IncoherentStokesBeam, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IncoherentStokesBeam')
    def exportChildren(self, outfile, level, namespace_='', name_='IncoherentStokesBeam', fromsubclass_=False, pretty_print=True):
        super(IncoherentStokesBeam, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(IncoherentStokesBeam, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IncoherentStokesBeam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IncoherentStokesBeam, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IncoherentStokesBeam, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(IncoherentStokesBeam, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IncoherentStokesBeam, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IncoherentStokesBeam


class FlysEyeBeam(ArrayBeam):
    subclass = None
    superclass = ArrayBeam
    def __init__(self, subArrayPointingIdentifier=None, beamNumber=None, dispersionMeasure=None, numberOfSubbands=None, stationSubbands=None, samplingTime=None, centralFrequencies=None, channelWidth=None, channelsPerSubband=None, stokes=None, station=None):
        super(FlysEyeBeam, self).__init__(subArrayPointingIdentifier, beamNumber, dispersionMeasure, numberOfSubbands, stationSubbands, samplingTime, centralFrequencies, channelWidth, channelsPerSubband, stokes, )
        self.station = station
    def factory(*args_, **kwargs_):
        if FlysEyeBeam.subclass:
            return FlysEyeBeam.subclass(*args_, **kwargs_)
        else:
            return FlysEyeBeam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def export(self, outfile, level, namespace_='', name_='FlysEyeBeam', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlysEyeBeam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlysEyeBeam'):
        super(FlysEyeBeam, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlysEyeBeam')
    def exportChildren(self, outfile, level, namespace_='', name_='FlysEyeBeam', fromsubclass_=False, pretty_print=True):
        super(FlysEyeBeam, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.station is not None:
            self.station.export(outfile, level, namespace_, name_='station', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.station is not None or
            super(FlysEyeBeam, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FlysEyeBeam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlysEyeBeam, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlysEyeBeam, self).exportLiteralChildren(outfile, level, name_)
        if self.station is not None:
            showIndent(outfile, level)
            outfile.write('station=model_.Station(\n')
            self.station.exportLiteral(outfile, level, name_='station')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(FlysEyeBeam, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'station':
            obj_ = Station.factory()
            obj_.build(child_)
            self.set_station(obj_)
        super(FlysEyeBeam, self).buildChildren(child_, node, nodeName_, True)
# end class FlysEyeBeam


class BeamFormedDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, numberOfBeams=None, beams=None):
        super(BeamFormedDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        self.numberOfBeams = numberOfBeams
        self.beams = beams
    def factory(*args_, **kwargs_):
        if BeamFormedDataProduct.subclass:
            return BeamFormedDataProduct.subclass(*args_, **kwargs_)
        else:
            return BeamFormedDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfBeams(self): return self.numberOfBeams
    def set_numberOfBeams(self, numberOfBeams): self.numberOfBeams = numberOfBeams
    def get_beams(self): return self.beams
    def set_beams(self, beams): self.beams = beams
    def export(self, outfile, level, namespace_='', name_='BeamFormedDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BeamFormedDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BeamFormedDataProduct'):
        super(BeamFormedDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BeamFormedDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='BeamFormedDataProduct', fromsubclass_=False, pretty_print=True):
        super(BeamFormedDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberOfBeams is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfBeams>%s</%snumberOfBeams>%s' % (namespace_, self.gds_format_integer(self.numberOfBeams, input_name='numberOfBeams'), namespace_, eol_))
        if self.beams is not None:
            self.beams.export(outfile, level, namespace_, name_='beams', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.numberOfBeams is not None or
            self.beams is not None or
            super(BeamFormedDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BeamFormedDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BeamFormedDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BeamFormedDataProduct, self).exportLiteralChildren(outfile, level, name_)
        if self.numberOfBeams is not None:
            showIndent(outfile, level)
            outfile.write('numberOfBeams=%d,\n' % self.numberOfBeams)
        if self.beams is not None:
            showIndent(outfile, level)
            outfile.write('beams=model_.ArrayBeams(\n')
            self.beams.exportLiteral(outfile, level, name_='beams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BeamFormedDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfBeams':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfBeams')
            self.numberOfBeams = ival_
        elif nodeName_ == 'beams':
            obj_ = ArrayBeams.factory()
            obj_.build(child_)
            self.set_beams(obj_)
        super(BeamFormedDataProduct, self).buildChildren(child_, node, nodeName_, True)
# end class BeamFormedDataProduct


class PulpDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, fileContent=None, observationProcessIdentifier=None, subArrayPointingIdentifier=None, beamNumber=None, beam=None):
        super(PulpDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        self.fileContent = fileContent
        self.observationProcessIdentifier = observationProcessIdentifier
        self.subArrayPointingIdentifier = subArrayPointingIdentifier
        self.beamNumber = beamNumber
        self.beam = beam
    def factory(*args_, **kwargs_):
        if PulpDataProduct.subclass:
            return PulpDataProduct.subclass(*args_, **kwargs_)
        else:
            return PulpDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileContent(self): return self.fileContent
    def set_fileContent(self, fileContent): self.fileContent = fileContent
    def validate_ListOfString(self, value):
        # Validate type ListOfString, a restriction on xs:string.
        pass
    def get_observationProcessIdentifier(self): return self.observationProcessIdentifier
    def set_observationProcessIdentifier(self, observationProcessIdentifier): self.observationProcessIdentifier = observationProcessIdentifier
    def get_subArrayPointingIdentifier(self): return self.subArrayPointingIdentifier
    def set_subArrayPointingIdentifier(self, subArrayPointingIdentifier): self.subArrayPointingIdentifier = subArrayPointingIdentifier
    def get_beamNumber(self): return self.beamNumber
    def set_beamNumber(self, beamNumber): self.beamNumber = beamNumber
    def get_beam(self): return self.beam
    def set_beam(self, beam): self.beam = beam
    def export(self, outfile, level, namespace_='', name_='PulpDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PulpDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PulpDataProduct'):
        super(PulpDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PulpDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='PulpDataProduct', fromsubclass_=False, pretty_print=True):
        super(PulpDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileContent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileContent>%s</%sfileContent>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.fileContent)).encode(ExternalEncoding), input_name='fileContent'), namespace_, eol_))
        if self.observationProcessIdentifier is not None:
            self.observationProcessIdentifier.export(outfile, level, namespace_, name_='observationProcessIdentifier', pretty_print=pretty_print)
        if self.subArrayPointingIdentifier is not None:
            self.subArrayPointingIdentifier.export(outfile, level, namespace_, name_='subArrayPointingIdentifier', pretty_print=pretty_print)
        if self.beamNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeamNumber>%s</%sbeamNumber>%s' % (namespace_, self.gds_format_integer(self.beamNumber, input_name='beamNumber'), namespace_, eol_))
        if self.beam is not None:
            self.beam.export(outfile, level, namespace_, name_='beam', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.fileContent is not None or
            self.observationProcessIdentifier is not None or
            self.subArrayPointingIdentifier is not None or
            self.beamNumber is not None or
            self.beam is not None or
            super(PulpDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PulpDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PulpDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PulpDataProduct, self).exportLiteralChildren(outfile, level, name_)
        if self.fileContent is not None:
            showIndent(outfile, level)
            if self.fileContent:
                outfile.write('fileContent=%s,\n' % quote_python(' '.join(self.fileContent)).encode(ExternalEncoding)) 
            else:
                outfile.write('fileContent=None,\n')
        if self.observationProcessIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('observationProcessIdentifier=model_.IdentifierType(\n')
            self.observationProcessIdentifier.exportLiteral(outfile, level, name_='observationProcessIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subArrayPointingIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('subArrayPointingIdentifier=model_.IdentifierType(\n')
            self.subArrayPointingIdentifier.exportLiteral(outfile, level, name_='subArrayPointingIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.beamNumber is not None:
            showIndent(outfile, level)
            outfile.write('beamNumber=%d,\n' % self.beamNumber)
        if self.beam is not None:
            showIndent(outfile, level)
            outfile.write('beam=model_.ArrayBeam(\n')
            self.beam.exportLiteral(outfile, level, name_='beam')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PulpDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileContent':
            fileContent_ = child_.text
            self.fileContent = fileContent_
            self.fileContent = self.fileContent.split()
            self.validate_ListOfString(self.fileContent)    # validate type ListOfString
        elif nodeName_ == 'observationProcessIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_observationProcessIdentifier(obj_)
        elif nodeName_ == 'subArrayPointingIdentifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_subArrayPointingIdentifier(obj_)
        elif nodeName_ == 'beamNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beamNumber')
            self.beamNumber = ival_
        elif nodeName_ == 'beam':
            class_obj_ = self.get_class_obj_(child_, ArrayBeam)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_beam(obj_)
        super(PulpDataProduct, self).buildChildren(child_, node, nodeName_, True)
# end class PulpDataProduct


class GenericDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None):
        super(GenericDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        pass
    def factory(*args_, **kwargs_):
        if GenericDataProduct.subclass:
            return GenericDataProduct.subclass(*args_, **kwargs_)
        else:
            return GenericDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='GenericDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenericDataProduct'):
        super(GenericDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GenericDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='GenericDataProduct', fromsubclass_=False, pretty_print=True):
        super(GenericDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(GenericDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GenericDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GenericDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GenericDataProduct, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericDataProduct, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericDataProduct


class UnspecifiedDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None):
        super(UnspecifiedDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, )
        pass
    def factory(*args_, **kwargs_):
        if UnspecifiedDataProduct.subclass:
            return UnspecifiedDataProduct.subclass(*args_, **kwargs_)
        else:
            return UnspecifiedDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='UnspecifiedDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnspecifiedDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnspecifiedDataProduct'):
        super(UnspecifiedDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UnspecifiedDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='UnspecifiedDataProduct', fromsubclass_=False, pretty_print=True):
        super(UnspecifiedDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(UnspecifiedDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnspecifiedDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UnspecifiedDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UnspecifiedDataProduct, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(UnspecifiedDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UnspecifiedDataProduct, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UnspecifiedDataProduct


class Axis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, name=None, units=None, length=None, extensiontype_=None):
        self.number = number
        self.name = name
        self.units = units
        self.length = length
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Axis.subclass:
            return Axis.subclass(*args_, **kwargs_)
        else:
            return Axis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Axis', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Axis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Axis'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Axis', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_format_integer(self.number, input_name='number'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunits>%s</%sunits>%s' % (namespace_, self.gds_format_string(quote_xml(self.units).encode(ExternalEncoding), input_name='units'), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.number is not None or
            self.name is not None or
            self.units is not None or
            self.length is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Axis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.number is not None:
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % self.number)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units=%s,\n' % quote_python(self.units).encode(ExternalEncoding))
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length=%d,\n' % self.length)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'number':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'number')
            self.number = ival_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
# end class Axis


class LinearAxis(Axis):
    subclass = None
    superclass = Axis
    def __init__(self, number=None, name=None, units=None, length=None, increment=None, referencePixel=None, referenceValue=None):
        super(LinearAxis, self).__init__(number, name, units, length, )
        self.increment = increment
        self.referencePixel = referencePixel
        self.referenceValue = referenceValue
    def factory(*args_, **kwargs_):
        if LinearAxis.subclass:
            return LinearAxis.subclass(*args_, **kwargs_)
        else:
            return LinearAxis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_increment(self): return self.increment
    def set_increment(self, increment): self.increment = increment
    def get_referencePixel(self): return self.referencePixel
    def set_referencePixel(self, referencePixel): self.referencePixel = referencePixel
    def get_referenceValue(self): return self.referenceValue
    def set_referenceValue(self, referenceValue): self.referenceValue = referenceValue
    def export(self, outfile, level, namespace_='', name_='LinearAxis', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearAxis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearAxis'):
        super(LinearAxis, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinearAxis')
    def exportChildren(self, outfile, level, namespace_='', name_='LinearAxis', fromsubclass_=False, pretty_print=True):
        super(LinearAxis, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.increment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sincrement>%s</%sincrement>%s' % (namespace_, self.gds_format_double(self.increment, input_name='increment'), namespace_, eol_))
        if self.referencePixel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferencePixel>%s</%sreferencePixel>%s' % (namespace_, self.gds_format_double(self.referencePixel, input_name='referencePixel'), namespace_, eol_))
        if self.referenceValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceValue>%s</%sreferenceValue>%s' % (namespace_, self.gds_format_double(self.referenceValue, input_name='referenceValue'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.increment is not None or
            self.referencePixel is not None or
            self.referenceValue is not None or
            super(LinearAxis, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearAxis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LinearAxis, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LinearAxis, self).exportLiteralChildren(outfile, level, name_)
        if self.increment is not None:
            showIndent(outfile, level)
            outfile.write('increment=%e,\n' % self.increment)
        if self.referencePixel is not None:
            showIndent(outfile, level)
            outfile.write('referencePixel=%e,\n' % self.referencePixel)
        if self.referenceValue is not None:
            showIndent(outfile, level)
            outfile.write('referenceValue=%e,\n' % self.referenceValue)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LinearAxis, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'increment':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'increment')
            self.increment = fval_
        elif nodeName_ == 'referencePixel':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'referencePixel')
            self.referencePixel = fval_
        elif nodeName_ == 'referenceValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'referenceValue')
            self.referenceValue = fval_
        super(LinearAxis, self).buildChildren(child_, node, nodeName_, True)
# end class LinearAxis


class TabularAxis(Axis):
    subclass = None
    superclass = Axis
    def __init__(self, number=None, name=None, units=None, length=None):
        super(TabularAxis, self).__init__(number, name, units, length, )
        pass
    def factory(*args_, **kwargs_):
        if TabularAxis.subclass:
            return TabularAxis.subclass(*args_, **kwargs_)
        else:
            return TabularAxis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='TabularAxis', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TabularAxis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TabularAxis'):
        super(TabularAxis, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TabularAxis')
    def exportChildren(self, outfile, level, namespace_='', name_='TabularAxis', fromsubclass_=False, pretty_print=True):
        super(TabularAxis, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(TabularAxis, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TabularAxis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TabularAxis, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TabularAxis, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TabularAxis, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TabularAxis, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TabularAxis


class Coordinate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Coordinate.subclass:
            return Coordinate.subclass(*args_, **kwargs_)
        else:
            return Coordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Coordinate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Coordinate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Coordinate'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Coordinate', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Coordinate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Coordinate


class DirectionCoordinate(Coordinate):
    subclass = None
    superclass = Coordinate
    def __init__(self, directionLinearAxis=None, PC0_0=None, PC0_1=None, PC1_0=None, PC1_1=None, equinox=None, raDecSystem=None, projection=None, projectionParameters=None, longitudePole=None, latitudePole=None):
        super(DirectionCoordinate, self).__init__()
        if directionLinearAxis is None:
            self.directionLinearAxis = []
        else:
            self.directionLinearAxis = directionLinearAxis
        self.PC0_0 = PC0_0
        self.PC0_1 = PC0_1
        self.PC1_0 = PC1_0
        self.PC1_1 = PC1_1
        self.equinox = equinox
        self.raDecSystem = raDecSystem
        self.projection = projection
        self.projectionParameters = projectionParameters
        self.longitudePole = longitudePole
        self.latitudePole = latitudePole
    def factory(*args_, **kwargs_):
        if DirectionCoordinate.subclass:
            return DirectionCoordinate.subclass(*args_, **kwargs_)
        else:
            return DirectionCoordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directionLinearAxis(self): return self.directionLinearAxis
    def set_directionLinearAxis(self, directionLinearAxis): self.directionLinearAxis = directionLinearAxis
    def add_directionLinearAxis(self, value): self.directionLinearAxis.append(value)
    def insert_directionLinearAxis(self, index, value): self.directionLinearAxis[index] = value
    def get_PC0_0(self): return self.PC0_0
    def set_PC0_0(self, PC0_0): self.PC0_0 = PC0_0
    def get_PC0_1(self): return self.PC0_1
    def set_PC0_1(self, PC0_1): self.PC0_1 = PC0_1
    def get_PC1_0(self): return self.PC1_0
    def set_PC1_0(self, PC1_0): self.PC1_0 = PC1_0
    def get_PC1_1(self): return self.PC1_1
    def set_PC1_1(self, PC1_1): self.PC1_1 = PC1_1
    def get_equinox(self): return self.equinox
    def set_equinox(self, equinox): self.equinox = equinox
    def get_raDecSystem(self): return self.raDecSystem
    def set_raDecSystem(self, raDecSystem): self.raDecSystem = raDecSystem
    def validate_RaDecSystem(self, value):
        # Validate type RaDecSystem, a restriction on xs:string.
        pass
    def get_projection(self): return self.projection
    def set_projection(self, projection): self.projection = projection
    def get_projectionParameters(self): return self.projectionParameters
    def set_projectionParameters(self, projectionParameters): self.projectionParameters = projectionParameters
    def validate_ListOfDouble(self, value):
        # Validate type ListOfDouble, a restriction on xs:double.
        pass
    def get_longitudePole(self): return self.longitudePole
    def set_longitudePole(self, longitudePole): self.longitudePole = longitudePole
    def get_latitudePole(self): return self.latitudePole
    def set_latitudePole(self, latitudePole): self.latitudePole = latitudePole
    def export(self, outfile, level, namespace_='', name_='DirectionCoordinate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionCoordinate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DirectionCoordinate'):
        super(DirectionCoordinate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectionCoordinate')
    def exportChildren(self, outfile, level, namespace_='', name_='DirectionCoordinate', fromsubclass_=False, pretty_print=True):
        super(DirectionCoordinate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for directionLinearAxis_ in self.directionLinearAxis:
            directionLinearAxis_.export(outfile, level, namespace_, name_='directionLinearAxis', pretty_print=pretty_print)
        if self.PC0_0 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPC0_0>%s</%sPC0_0>%s' % (namespace_, self.gds_format_double(self.PC0_0, input_name='PC0_0'), namespace_, eol_))
        if self.PC0_1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPC0_1>%s</%sPC0_1>%s' % (namespace_, self.gds_format_double(self.PC0_1, input_name='PC0_1'), namespace_, eol_))
        if self.PC1_0 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPC1_0>%s</%sPC1_0>%s' % (namespace_, self.gds_format_double(self.PC1_0, input_name='PC1_0'), namespace_, eol_))
        if self.PC1_1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPC1_1>%s</%sPC1_1>%s' % (namespace_, self.gds_format_double(self.PC1_1, input_name='PC1_1'), namespace_, eol_))
        if self.equinox is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequinox>%s</%sequinox>%s' % (namespace_, self.gds_format_string(quote_xml(self.equinox).encode(ExternalEncoding), input_name='equinox'), namespace_, eol_))
        if self.raDecSystem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sraDecSystem>%s</%sraDecSystem>%s' % (namespace_, self.gds_format_string(quote_xml(self.raDecSystem).encode(ExternalEncoding), input_name='raDecSystem'), namespace_, eol_))
        if self.projection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprojection>%s</%sprojection>%s' % (namespace_, self.gds_format_string(quote_xml(self.projection).encode(ExternalEncoding), input_name='projection'), namespace_, eol_))
        if self.projectionParameters is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprojectionParameters>%s</%sprojectionParameters>%s' % (namespace_, self.gds_format_double_list(self.projectionParameters, input_name='projectionParameters'), namespace_, eol_))
        if self.longitudePole is not None:
            self.longitudePole.export(outfile, level, namespace_, name_='longitudePole', pretty_print=pretty_print)
        if self.latitudePole is not None:
            self.latitudePole.export(outfile, level, namespace_, name_='latitudePole', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.directionLinearAxis or
            self.PC0_0 is not None or
            self.PC0_1 is not None or
            self.PC1_0 is not None or
            self.PC1_1 is not None or
            self.equinox is not None or
            self.raDecSystem is not None or
            self.projection is not None or
            self.projectionParameters is not None or
            self.longitudePole is not None or
            self.latitudePole is not None or
            super(DirectionCoordinate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectionCoordinate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DirectionCoordinate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DirectionCoordinate, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('directionLinearAxis=[\n')
        level += 1
        for directionLinearAxis_ in self.directionLinearAxis:
            showIndent(outfile, level)
            outfile.write('model_.LinearAxis(\n')
            directionLinearAxis_.exportLiteral(outfile, level, name_='LinearAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PC0_0 is not None:
            showIndent(outfile, level)
            outfile.write('PC0_0=%e,\n' % self.PC0_0)
        if self.PC0_1 is not None:
            showIndent(outfile, level)
            outfile.write('PC0_1=%e,\n' % self.PC0_1)
        if self.PC1_0 is not None:
            showIndent(outfile, level)
            outfile.write('PC1_0=%e,\n' % self.PC1_0)
        if self.PC1_1 is not None:
            showIndent(outfile, level)
            outfile.write('PC1_1=%e,\n' % self.PC1_1)
        if self.equinox is not None:
            showIndent(outfile, level)
            outfile.write('equinox=%s,\n' % quote_python(self.equinox).encode(ExternalEncoding))
        if self.raDecSystem is not None:
            showIndent(outfile, level)
            outfile.write('raDecSystem=%s,\n' % quote_python(self.raDecSystem).encode(ExternalEncoding))
        if self.projection is not None:
            showIndent(outfile, level)
            outfile.write('projection=%s,\n' % quote_python(self.projection).encode(ExternalEncoding))
        if self.projectionParameters is not None:
            showIndent(outfile, level)
            outfile.write('projectionParameters=%e,\n' % self.projectionParameters)
        if self.longitudePole is not None:
            showIndent(outfile, level)
            outfile.write('longitudePole=model_.Angle(\n')
            self.longitudePole.exportLiteral(outfile, level, name_='longitudePole')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.latitudePole is not None:
            showIndent(outfile, level)
            outfile.write('latitudePole=model_.Angle(\n')
            self.latitudePole.exportLiteral(outfile, level, name_='latitudePole')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DirectionCoordinate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'directionLinearAxis':
            obj_ = LinearAxis.factory()
            obj_.build(child_)
            self.directionLinearAxis.append(obj_)
        elif nodeName_ == 'PC0_0':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PC0_0')
            self.PC0_0 = fval_
        elif nodeName_ == 'PC0_1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PC0_1')
            self.PC0_1 = fval_
        elif nodeName_ == 'PC1_0':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PC1_0')
            self.PC1_0 = fval_
        elif nodeName_ == 'PC1_1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PC1_1')
            self.PC1_1 = fval_
        elif nodeName_ == 'equinox':
            equinox_ = child_.text
            equinox_ = self.gds_validate_string(equinox_, node, 'equinox')
            self.equinox = equinox_
        elif nodeName_ == 'raDecSystem':
            raDecSystem_ = child_.text
            raDecSystem_ = self.gds_validate_string(raDecSystem_, node, 'raDecSystem')
            self.raDecSystem = raDecSystem_
            self.validate_RaDecSystem(self.raDecSystem)    # validate type RaDecSystem
        elif nodeName_ == 'projection':
            projection_ = child_.text
            projection_ = self.gds_validate_string(projection_, node, 'projection')
            self.projection = projection_
        elif nodeName_ == 'projectionParameters':
            projectionParameters_ = child_.text
            projectionParameters_ = self.gds_validate_double_list(projectionParameters_, node, 'projectionParameters')
            self.projectionParameters = projectionParameters_
            self.projectionParameters = self.projectionParameters.split()
            self.validate_ListOfDouble(self.projectionParameters)    # validate type ListOfDouble
        elif nodeName_ == 'longitudePole':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_longitudePole(obj_)
        elif nodeName_ == 'latitudePole':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_latitudePole(obj_)
        super(DirectionCoordinate, self).buildChildren(child_, node, nodeName_, True)
# end class DirectionCoordinate


class SpectralQuantity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.type_ = type_
        self.value = value
    def factory(*args_, **kwargs_):
        if SpectralQuantity.subclass:
            return SpectralQuantity.subclass(*args_, **kwargs_)
        else:
            return SpectralQuantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_SpectralQuantityType(self, value):
        # Validate type SpectralQuantityType, a restriction on xs:string.
        pass
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='SpectralQuantity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralQuantity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpectralQuantity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpectralQuantity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_double(self.value, input_name='value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpectralQuantity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % self.value)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            self.validate_SpectralQuantityType(self.type_)    # validate type SpectralQuantityType
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'value')
            self.value = fval_
# end class SpectralQuantity


class SpectralCoordinate(Coordinate):
    subclass = None
    superclass = Coordinate
    def __init__(self, spectralLinearAxis=None, spectralTabularAxis=None, spectralQuantity=None):
        super(SpectralCoordinate, self).__init__()
        self.spectralLinearAxis = spectralLinearAxis
        self.spectralTabularAxis = spectralTabularAxis
        self.spectralQuantity = spectralQuantity
    def factory(*args_, **kwargs_):
        if SpectralCoordinate.subclass:
            return SpectralCoordinate.subclass(*args_, **kwargs_)
        else:
            return SpectralCoordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectralLinearAxis(self): return self.spectralLinearAxis
    def set_spectralLinearAxis(self, spectralLinearAxis): self.spectralLinearAxis = spectralLinearAxis
    def get_spectralTabularAxis(self): return self.spectralTabularAxis
    def set_spectralTabularAxis(self, spectralTabularAxis): self.spectralTabularAxis = spectralTabularAxis
    def get_spectralQuantity(self): return self.spectralQuantity
    def set_spectralQuantity(self, spectralQuantity): self.spectralQuantity = spectralQuantity
    def export(self, outfile, level, namespace_='', name_='SpectralCoordinate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralCoordinate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpectralCoordinate'):
        super(SpectralCoordinate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralCoordinate')
    def exportChildren(self, outfile, level, namespace_='', name_='SpectralCoordinate', fromsubclass_=False, pretty_print=True):
        super(SpectralCoordinate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.spectralLinearAxis is not None:
            self.spectralLinearAxis.export(outfile, level, namespace_, name_='spectralLinearAxis', pretty_print=pretty_print)
        if self.spectralTabularAxis is not None:
            self.spectralTabularAxis.export(outfile, level, namespace_, name_='spectralTabularAxis', pretty_print=pretty_print)
        if self.spectralQuantity is not None:
            self.spectralQuantity.export(outfile, level, namespace_, name_='spectralQuantity', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.spectralLinearAxis is not None or
            self.spectralTabularAxis is not None or
            self.spectralQuantity is not None or
            super(SpectralCoordinate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpectralCoordinate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SpectralCoordinate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SpectralCoordinate, self).exportLiteralChildren(outfile, level, name_)
        if self.spectralLinearAxis is not None:
            showIndent(outfile, level)
            outfile.write('spectralLinearAxis=model_.LinearAxis(\n')
            self.spectralLinearAxis.exportLiteral(outfile, level, name_='spectralLinearAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spectralTabularAxis is not None:
            showIndent(outfile, level)
            outfile.write('spectralTabularAxis=model_.TabularAxis(\n')
            self.spectralTabularAxis.exportLiteral(outfile, level, name_='spectralTabularAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.spectralQuantity is not None:
            showIndent(outfile, level)
            outfile.write('spectralQuantity=model_.SpectralQuantity(\n')
            self.spectralQuantity.exportLiteral(outfile, level, name_='spectralQuantity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SpectralCoordinate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spectralLinearAxis':
            obj_ = LinearAxis.factory()
            obj_.build(child_)
            self.set_spectralLinearAxis(obj_)
        elif nodeName_ == 'spectralTabularAxis':
            obj_ = TabularAxis.factory()
            obj_.build(child_)
            self.set_spectralTabularAxis(obj_)
        elif nodeName_ == 'spectralQuantity':
            obj_ = SpectralQuantity.factory()
            obj_.build(child_)
            self.set_spectralQuantity(obj_)
        super(SpectralCoordinate, self).buildChildren(child_, node, nodeName_, True)
# end class SpectralCoordinate


class TimeCoordinate(Coordinate):
    subclass = None
    superclass = Coordinate
    def __init__(self, timeLinearAxis=None, timeTabularAxis=None, equinox=None):
        super(TimeCoordinate, self).__init__()
        self.timeLinearAxis = timeLinearAxis
        self.timeTabularAxis = timeTabularAxis
        self.equinox = equinox
    def factory(*args_, **kwargs_):
        if TimeCoordinate.subclass:
            return TimeCoordinate.subclass(*args_, **kwargs_)
        else:
            return TimeCoordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeLinearAxis(self): return self.timeLinearAxis
    def set_timeLinearAxis(self, timeLinearAxis): self.timeLinearAxis = timeLinearAxis
    def get_timeTabularAxis(self): return self.timeTabularAxis
    def set_timeTabularAxis(self, timeTabularAxis): self.timeTabularAxis = timeTabularAxis
    def get_equinox(self): return self.equinox
    def set_equinox(self, equinox): self.equinox = equinox
    def validate_EquinoxType(self, value):
        # Validate type EquinoxType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='TimeCoordinate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCoordinate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCoordinate'):
        super(TimeCoordinate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCoordinate')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCoordinate', fromsubclass_=False, pretty_print=True):
        super(TimeCoordinate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.timeLinearAxis is not None:
            self.timeLinearAxis.export(outfile, level, namespace_, name_='timeLinearAxis', pretty_print=pretty_print)
        if self.timeTabularAxis is not None:
            self.timeTabularAxis.export(outfile, level, namespace_, name_='timeTabularAxis', pretty_print=pretty_print)
        if self.equinox is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sequinox>%s</%sequinox>%s' % (namespace_, self.gds_format_string(quote_xml(self.equinox).encode(ExternalEncoding), input_name='equinox'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.timeLinearAxis is not None or
            self.timeTabularAxis is not None or
            self.equinox is not None or
            super(TimeCoordinate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeCoordinate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeCoordinate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeCoordinate, self).exportLiteralChildren(outfile, level, name_)
        if self.timeLinearAxis is not None:
            showIndent(outfile, level)
            outfile.write('timeLinearAxis=model_.LinearAxis(\n')
            self.timeLinearAxis.exportLiteral(outfile, level, name_='timeLinearAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeTabularAxis is not None:
            showIndent(outfile, level)
            outfile.write('timeTabularAxis=model_.TabularAxis(\n')
            self.timeTabularAxis.exportLiteral(outfile, level, name_='timeTabularAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.equinox is not None:
            showIndent(outfile, level)
            outfile.write('equinox=%s,\n' % quote_python(self.equinox).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeCoordinate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timeLinearAxis':
            obj_ = LinearAxis.factory()
            obj_.build(child_)
            self.set_timeLinearAxis(obj_)
        elif nodeName_ == 'timeTabularAxis':
            obj_ = TabularAxis.factory()
            obj_.build(child_)
            self.set_timeTabularAxis(obj_)
        elif nodeName_ == 'equinox':
            equinox_ = child_.text
            equinox_ = self.gds_validate_string(equinox_, node, 'equinox')
            self.equinox = equinox_
            self.validate_EquinoxType(self.equinox)    # validate type EquinoxType
        super(TimeCoordinate, self).buildChildren(child_, node, nodeName_, True)
# end class TimeCoordinate


class PolarizationCoordinate(Coordinate):
    subclass = None
    superclass = Coordinate
    def __init__(self, polarizationTabularAxis=None, polarization=None):
        super(PolarizationCoordinate, self).__init__()
        self.polarizationTabularAxis = polarizationTabularAxis
        if polarization is None:
            self.polarization = []
        else:
            self.polarization = polarization
    def factory(*args_, **kwargs_):
        if PolarizationCoordinate.subclass:
            return PolarizationCoordinate.subclass(*args_, **kwargs_)
        else:
            return PolarizationCoordinate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polarizationTabularAxis(self): return self.polarizationTabularAxis
    def set_polarizationTabularAxis(self, polarizationTabularAxis): self.polarizationTabularAxis = polarizationTabularAxis
    def get_polarization(self): return self.polarization
    def set_polarization(self, polarization): self.polarization = polarization
    def add_polarization(self, value): self.polarization.append(value)
    def insert_polarization(self, index, value): self.polarization[index] = value
    def validate_PolarizationType(self, value):
        # Validate type PolarizationType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PolarizationCoordinate', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolarizationCoordinate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolarizationCoordinate'):
        super(PolarizationCoordinate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PolarizationCoordinate')
    def exportChildren(self, outfile, level, namespace_='', name_='PolarizationCoordinate', fromsubclass_=False, pretty_print=True):
        super(PolarizationCoordinate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.polarizationTabularAxis is not None:
            self.polarizationTabularAxis.export(outfile, level, namespace_, name_='polarizationTabularAxis', pretty_print=pretty_print)
        for polarization_ in self.polarization:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolarization>%s</%spolarization>%s' % (namespace_, self.gds_format_string(quote_xml(polarization_).encode(ExternalEncoding), input_name='polarization'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.polarizationTabularAxis is not None or
            self.polarization or
            super(PolarizationCoordinate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolarizationCoordinate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PolarizationCoordinate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PolarizationCoordinate, self).exportLiteralChildren(outfile, level, name_)
        if self.polarizationTabularAxis is not None:
            showIndent(outfile, level)
            outfile.write('polarizationTabularAxis=model_.TabularAxis(\n')
            self.polarizationTabularAxis.exportLiteral(outfile, level, name_='polarizationTabularAxis')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('polarization=[\n')
        level += 1
        for polarization_ in self.polarization:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(polarization_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PolarizationCoordinate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polarizationTabularAxis':
            obj_ = TabularAxis.factory()
            obj_.build(child_)
            self.set_polarizationTabularAxis(obj_)
        elif nodeName_ == 'polarization':
            polarization_ = child_.text
            polarization_ = self.gds_validate_string(polarization_, node, 'polarization')
            self.polarization.append(polarization_)
            self.validate_PolarizationType(self.polarization)    # validate type PolarizationType
        super(PolarizationCoordinate, self).buildChildren(child_, node, nodeName_, True)
# end class PolarizationCoordinate


class PixelMapDataProduct(DataProduct):
    subclass = None
    superclass = DataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, numberOfAxes=None, numberOfCoordinates=None, coordinate=None, extensiontype_=None):
        super(PixelMapDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, extensiontype_, )
        self.numberOfAxes = numberOfAxes
        self.numberOfCoordinates = numberOfCoordinates
        if coordinate is None:
            self.coordinate = []
        else:
            self.coordinate = coordinate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PixelMapDataProduct.subclass:
            return PixelMapDataProduct.subclass(*args_, **kwargs_)
        else:
            return PixelMapDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfAxes(self): return self.numberOfAxes
    def set_numberOfAxes(self, numberOfAxes): self.numberOfAxes = numberOfAxes
    def get_numberOfCoordinates(self): return self.numberOfCoordinates
    def set_numberOfCoordinates(self, numberOfCoordinates): self.numberOfCoordinates = numberOfCoordinates
    def get_coordinate(self): return self.coordinate
    def set_coordinate(self, coordinate): self.coordinate = coordinate
    def add_coordinate(self, value): self.coordinate.append(value)
    def insert_coordinate(self, index, value): self.coordinate[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='PixelMapDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PixelMapDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PixelMapDataProduct'):
        super(PixelMapDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PixelMapDataProduct')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PixelMapDataProduct', fromsubclass_=False, pretty_print=True):
        super(PixelMapDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberOfAxes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfAxes>%s</%snumberOfAxes>%s' % (namespace_, self.gds_format_integer(self.numberOfAxes, input_name='numberOfAxes'), namespace_, eol_))
        if self.numberOfCoordinates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfCoordinates>%s</%snumberOfCoordinates>%s' % (namespace_, self.gds_format_integer(self.numberOfCoordinates, input_name='numberOfCoordinates'), namespace_, eol_))
        for coordinate_ in self.coordinate:
            coordinate_.export(outfile, level, namespace_, name_='coordinate', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.numberOfAxes is not None or
            self.numberOfCoordinates is not None or
            self.coordinate or
            super(PixelMapDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PixelMapDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PixelMapDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PixelMapDataProduct, self).exportLiteralChildren(outfile, level, name_)
        if self.numberOfAxes is not None:
            showIndent(outfile, level)
            outfile.write('numberOfAxes=%d,\n' % self.numberOfAxes)
        if self.numberOfCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('numberOfCoordinates=%d,\n' % self.numberOfCoordinates)
        showIndent(outfile, level)
        outfile.write('coordinate=[\n')
        level += 1
        for coordinate_ in self.coordinate:
            showIndent(outfile, level)
            outfile.write('model_.Coordinate(\n')
            coordinate_.exportLiteral(outfile, level, name_='Coordinate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(PixelMapDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfAxes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfAxes')
            self.numberOfAxes = ival_
        elif nodeName_ == 'numberOfCoordinates':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfCoordinates')
            self.numberOfCoordinates = ival_
        elif nodeName_ == 'coordinate':
            class_obj_ = self.get_class_obj_(child_, Coordinate)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.coordinate.append(obj_)
        super(PixelMapDataProduct, self).buildChildren(child_, node, nodeName_, True)
# end class PixelMapDataProduct


class SkyImageDataProduct(PixelMapDataProduct):
    subclass = None
    superclass = PixelMapDataProduct
    def __init__(self, dataProductType=None, dataProductIdentifier=None, storageTicket=None, size=None, checksum=None, fileName=None, fileFormat=None, processIdentifier=None, numberOfAxes=None, numberOfCoordinates=None, coordinate=None, locationFrame=None, timeFrame=None, observationPointing=None, restoringBeamMajor=None, restoringBeamMinor=None, rmsNoise=None):
        super(SkyImageDataProduct, self).__init__(dataProductType, dataProductIdentifier, storageTicket, size, checksum, fileName, fileFormat, processIdentifier, numberOfAxes, numberOfCoordinates, coordinate, )
        self.locationFrame = locationFrame
        self.timeFrame = timeFrame
        self.observationPointing = observationPointing
        self.restoringBeamMajor = restoringBeamMajor
        self.restoringBeamMinor = restoringBeamMinor
        self.rmsNoise = rmsNoise
    def factory(*args_, **kwargs_):
        if SkyImageDataProduct.subclass:
            return SkyImageDataProduct.subclass(*args_, **kwargs_)
        else:
            return SkyImageDataProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locationFrame(self): return self.locationFrame
    def set_locationFrame(self, locationFrame): self.locationFrame = locationFrame
    def validate_LocationFrame(self, value):
        # Validate type LocationFrame, a restriction on xs:string.
        pass
    def get_timeFrame(self): return self.timeFrame
    def set_timeFrame(self, timeFrame): self.timeFrame = timeFrame
    def get_observationPointing(self): return self.observationPointing
    def set_observationPointing(self, observationPointing): self.observationPointing = observationPointing
    def get_restoringBeamMajor(self): return self.restoringBeamMajor
    def set_restoringBeamMajor(self, restoringBeamMajor): self.restoringBeamMajor = restoringBeamMajor
    def get_restoringBeamMinor(self): return self.restoringBeamMinor
    def set_restoringBeamMinor(self, restoringBeamMinor): self.restoringBeamMinor = restoringBeamMinor
    def get_rmsNoise(self): return self.rmsNoise
    def set_rmsNoise(self, rmsNoise): self.rmsNoise = rmsNoise
    def export(self, outfile, level, namespace_='', name_='SkyImageDataProduct', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SkyImageDataProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SkyImageDataProduct'):
        super(SkyImageDataProduct, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SkyImageDataProduct')
    def exportChildren(self, outfile, level, namespace_='', name_='SkyImageDataProduct', fromsubclass_=False, pretty_print=True):
        super(SkyImageDataProduct, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.locationFrame is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocationFrame>%s</%slocationFrame>%s' % (namespace_, self.gds_format_string(quote_xml(self.locationFrame).encode(ExternalEncoding), input_name='locationFrame'), namespace_, eol_))
        if self.timeFrame is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeFrame>%s</%stimeFrame>%s' % (namespace_, self.gds_format_string(quote_xml(self.timeFrame).encode(ExternalEncoding), input_name='timeFrame'), namespace_, eol_))
        if self.observationPointing is not None:
            self.observationPointing.export(outfile, level, namespace_, name_='observationPointing', pretty_print=pretty_print)
        if self.restoringBeamMajor is not None:
            self.restoringBeamMajor.export(outfile, level, namespace_, name_='restoringBeamMajor', pretty_print=pretty_print)
        if self.restoringBeamMinor is not None:
            self.restoringBeamMinor.export(outfile, level, namespace_, name_='restoringBeamMinor', pretty_print=pretty_print)
        if self.rmsNoise is not None:
            self.rmsNoise.export(outfile, level, namespace_, name_='rmsNoise', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.locationFrame is not None or
            self.timeFrame is not None or
            self.observationPointing is not None or
            self.restoringBeamMajor is not None or
            self.restoringBeamMinor is not None or
            self.rmsNoise is not None or
            super(SkyImageDataProduct, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SkyImageDataProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SkyImageDataProduct, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SkyImageDataProduct, self).exportLiteralChildren(outfile, level, name_)
        if self.locationFrame is not None:
            showIndent(outfile, level)
            outfile.write('locationFrame=%s,\n' % quote_python(self.locationFrame).encode(ExternalEncoding))
        if self.timeFrame is not None:
            showIndent(outfile, level)
            outfile.write('timeFrame=%s,\n' % quote_python(self.timeFrame).encode(ExternalEncoding))
        if self.observationPointing is not None:
            showIndent(outfile, level)
            outfile.write('observationPointing=model_.Pointing(\n')
            self.observationPointing.exportLiteral(outfile, level, name_='observationPointing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.restoringBeamMajor is not None:
            showIndent(outfile, level)
            outfile.write('restoringBeamMajor=model_.Angle(\n')
            self.restoringBeamMajor.exportLiteral(outfile, level, name_='restoringBeamMajor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.restoringBeamMinor is not None:
            showIndent(outfile, level)
            outfile.write('restoringBeamMinor=model_.Angle(\n')
            self.restoringBeamMinor.exportLiteral(outfile, level, name_='restoringBeamMinor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rmsNoise is not None:
            showIndent(outfile, level)
            outfile.write('rmsNoise=model_.Pixel(\n')
            self.rmsNoise.exportLiteral(outfile, level, name_='rmsNoise')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SkyImageDataProduct, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'locationFrame':
            locationFrame_ = child_.text
            locationFrame_ = self.gds_validate_string(locationFrame_, node, 'locationFrame')
            self.locationFrame = locationFrame_
            self.validate_LocationFrame(self.locationFrame)    # validate type LocationFrame
        elif nodeName_ == 'timeFrame':
            timeFrame_ = child_.text
            timeFrame_ = self.gds_validate_string(timeFrame_, node, 'timeFrame')
            self.timeFrame = timeFrame_
        elif nodeName_ == 'observationPointing':
            obj_ = Pointing.factory()
            obj_.build(child_)
            self.set_observationPointing(obj_)
        elif nodeName_ == 'restoringBeamMajor':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_restoringBeamMajor(obj_)
        elif nodeName_ == 'restoringBeamMinor':
            obj_ = Angle.factory()
            obj_.build(child_)
            self.set_restoringBeamMinor(obj_)
        elif nodeName_ == 'rmsNoise':
            obj_ = Pixel.factory()
            obj_.build(child_)
            self.set_rmsNoise(obj_)
        super(SkyImageDataProduct, self).buildChildren(child_, node, nodeName_, True)
# end class SkyImageDataProduct


class Parset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, identifier=None, contents=None):
        self.identifier = identifier
        self.contents = contents
    def factory(*args_, **kwargs_):
        if Parset.subclass:
            return Parset.subclass(*args_, **kwargs_)
        else:
            return Parset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_contents(self): return self.contents
    def set_contents(self, contents): self.contents = contents
    def export(self, outfile, level, namespace_='', name_='Parset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parset'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Parset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
        if self.contents is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontents>%s</%scontents>%s' % (namespace_, self.gds_format_string(quote_xml(self.contents).encode(ExternalEncoding), input_name='contents'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.identifier is not None or
            self.contents is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Parset'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.IdentifierType(\n')
            self.identifier.exportLiteral(outfile, level, name_='identifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contents is not None:
            showIndent(outfile, level)
            outfile.write('contents=%s,\n' % quote_python(self.contents).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'contents':
            contents_ = child_.text
            contents_ = self.gds_validate_string(contents_, node, 'contents')
            self.contents = contents_
# end class Parset


class Project(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, projectCode=None, primaryInvestigator=None, coInvestigator=None, contactAuthor=None, telescope=None, projectDescription=None):
        self.projectCode = projectCode
        self.primaryInvestigator = primaryInvestigator
        if coInvestigator is None:
            self.coInvestigator = []
        else:
            self.coInvestigator = coInvestigator
        self.contactAuthor = contactAuthor
        self.telescope = telescope
        self.projectDescription = projectDescription
    def factory(*args_, **kwargs_):
        if Project.subclass:
            return Project.subclass(*args_, **kwargs_)
        else:
            return Project(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_projectCode(self): return self.projectCode
    def set_projectCode(self, projectCode): self.projectCode = projectCode
    def get_primaryInvestigator(self): return self.primaryInvestigator
    def set_primaryInvestigator(self, primaryInvestigator): self.primaryInvestigator = primaryInvestigator
    def get_coInvestigator(self): return self.coInvestigator
    def set_coInvestigator(self, coInvestigator): self.coInvestigator = coInvestigator
    def add_coInvestigator(self, value): self.coInvestigator.append(value)
    def insert_coInvestigator(self, index, value): self.coInvestigator[index] = value
    def get_contactAuthor(self): return self.contactAuthor
    def set_contactAuthor(self, contactAuthor): self.contactAuthor = contactAuthor
    def get_telescope(self): return self.telescope
    def set_telescope(self, telescope): self.telescope = telescope
    def validate_Telescope(self, value):
        # Validate type Telescope, a restriction on xs:string.
        pass
    def get_projectDescription(self): return self.projectDescription
    def set_projectDescription(self, projectDescription): self.projectDescription = projectDescription
    def export(self, outfile, level, namespace_='', name_='Project', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Project')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Project'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Project', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.projectCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprojectCode>%s</%sprojectCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.projectCode).encode(ExternalEncoding), input_name='projectCode'), namespace_, eol_))
        if self.primaryInvestigator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprimaryInvestigator>%s</%sprimaryInvestigator>%s' % (namespace_, self.gds_format_string(quote_xml(self.primaryInvestigator).encode(ExternalEncoding), input_name='primaryInvestigator'), namespace_, eol_))
        for coInvestigator_ in self.coInvestigator:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoInvestigator>%s</%scoInvestigator>%s' % (namespace_, self.gds_format_string(quote_xml(coInvestigator_).encode(ExternalEncoding), input_name='coInvestigator'), namespace_, eol_))
        if self.contactAuthor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontactAuthor>%s</%scontactAuthor>%s' % (namespace_, self.gds_format_string(quote_xml(self.contactAuthor).encode(ExternalEncoding), input_name='contactAuthor'), namespace_, eol_))
        if self.telescope is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stelescope>%s</%stelescope>%s' % (namespace_, self.gds_format_string(quote_xml(self.telescope).encode(ExternalEncoding), input_name='telescope'), namespace_, eol_))
        if self.projectDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprojectDescription>%s</%sprojectDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.projectDescription).encode(ExternalEncoding), input_name='projectDescription'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.projectCode is not None or
            self.primaryInvestigator is not None or
            self.coInvestigator or
            self.contactAuthor is not None or
            self.telescope is not None or
            self.projectDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Project'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.projectCode is not None:
            showIndent(outfile, level)
            outfile.write('projectCode=%s,\n' % quote_python(self.projectCode).encode(ExternalEncoding))
        if self.primaryInvestigator is not None:
            showIndent(outfile, level)
            outfile.write('primaryInvestigator=%s,\n' % quote_python(self.primaryInvestigator).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('coInvestigator=[\n')
        level += 1
        for coInvestigator_ in self.coInvestigator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(coInvestigator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.contactAuthor is not None:
            showIndent(outfile, level)
            outfile.write('contactAuthor=%s,\n' % quote_python(self.contactAuthor).encode(ExternalEncoding))
        if self.telescope is not None:
            showIndent(outfile, level)
            outfile.write('telescope=%s,\n' % quote_python(self.telescope).encode(ExternalEncoding))
        if self.projectDescription is not None:
            showIndent(outfile, level)
            outfile.write('projectDescription=%s,\n' % quote_python(self.projectDescription).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'projectCode':
            projectCode_ = child_.text
            projectCode_ = self.gds_validate_string(projectCode_, node, 'projectCode')
            self.projectCode = projectCode_
        elif nodeName_ == 'primaryInvestigator':
            primaryInvestigator_ = child_.text
            primaryInvestigator_ = self.gds_validate_string(primaryInvestigator_, node, 'primaryInvestigator')
            self.primaryInvestigator = primaryInvestigator_
        elif nodeName_ == 'coInvestigator':
            coInvestigator_ = child_.text
            coInvestigator_ = self.gds_validate_string(coInvestigator_, node, 'coInvestigator')
            self.coInvestigator.append(coInvestigator_)
        elif nodeName_ == 'contactAuthor':
            contactAuthor_ = child_.text
            contactAuthor_ = self.gds_validate_string(contactAuthor_, node, 'contactAuthor')
            self.contactAuthor = contactAuthor_
        elif nodeName_ == 'telescope':
            telescope_ = child_.text
            telescope_ = self.gds_validate_string(telescope_, node, 'telescope')
            self.telescope = telescope_
            self.validate_Telescope(self.telescope)    # validate type Telescope
        elif nodeName_ == 'projectDescription':
            projectDescription_ = child_.text
            projectDescription_ = self.gds_validate_string(projectDescription_, node, 'projectDescription')
            self.projectDescription = projectDescription_
# end class Project


class LTASip(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sipGeneratorVersion=None, project=None, dataProduct=None, observation=None, pipelineRun=None, relatedDataProduct=None, parset=None):
        self.sipGeneratorVersion = sipGeneratorVersion
        self.project = project
        self.dataProduct = dataProduct
        if observation is None:
            self.observation = []
        else:
            self.observation = observation
        if pipelineRun is None:
            self.pipelineRun = []
        else:
            self.pipelineRun = pipelineRun
        if relatedDataProduct is None:
            self.relatedDataProduct = []
        else:
            self.relatedDataProduct = relatedDataProduct
        if parset is None:
            self.parset = []
        else:
            self.parset = parset
    def factory(*args_, **kwargs_):
        if LTASip.subclass:
            return LTASip.subclass(*args_, **kwargs_)
        else:
            return LTASip(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sipGeneratorVersion(self): return self.sipGeneratorVersion
    def set_sipGeneratorVersion(self, sipGeneratorVersion): self.sipGeneratorVersion = sipGeneratorVersion
    def get_project(self): return self.project
    def set_project(self, project): self.project = project
    def get_dataProduct(self): return self.dataProduct
    def set_dataProduct(self, dataProduct): self.dataProduct = dataProduct
    def get_observation(self): return self.observation
    def set_observation(self, observation): self.observation = observation
    def add_observation(self, value): self.observation.append(value)
    def insert_observation(self, index, value): self.observation[index] = value
    def get_pipelineRun(self): return self.pipelineRun
    def set_pipelineRun(self, pipelineRun): self.pipelineRun = pipelineRun
    def add_pipelineRun(self, value): self.pipelineRun.append(value)
    def insert_pipelineRun(self, index, value): self.pipelineRun[index] = value
    def get_relatedDataProduct(self): return self.relatedDataProduct
    def set_relatedDataProduct(self, relatedDataProduct): self.relatedDataProduct = relatedDataProduct
    def add_relatedDataProduct(self, value): self.relatedDataProduct.append(value)
    def insert_relatedDataProduct(self, index, value): self.relatedDataProduct[index] = value
    def get_parset(self): return self.parset
    def set_parset(self, parset): self.parset = parset
    def add_parset(self, value): self.parset.append(value)
    def insert_parset(self, index, value): self.parset[index] = value
    def export(self, outfile, level, namespace_='', name_='LTASip', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LTASip')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LTASip'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LTASip', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sipGeneratorVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssipGeneratorVersion>%s</%ssipGeneratorVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.sipGeneratorVersion).encode(ExternalEncoding), input_name='sipGeneratorVersion'), namespace_, eol_))
        if self.project is not None:
            self.project.export(outfile, level, namespace_, name_='project', pretty_print=pretty_print)
        if self.dataProduct is not None:
            self.dataProduct.export(outfile, level, namespace_, name_='dataProduct', pretty_print=pretty_print)
        for observation_ in self.observation:
            observation_.export(outfile, level, namespace_, name_='observation', pretty_print=pretty_print)
        for pipelineRun_ in self.pipelineRun:
            pipelineRun_.export(outfile, level, namespace_, name_='pipelineRun', pretty_print=pretty_print)
        for relatedDataProduct_ in self.relatedDataProduct:
            relatedDataProduct_.export(outfile, level, namespace_, name_='relatedDataProduct', pretty_print=pretty_print)
        for parset_ in self.parset:
            parset_.export(outfile, level, namespace_, name_='parset', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.sipGeneratorVersion is not None or
            self.project is not None or
            self.dataProduct is not None or
            self.observation or
            self.pipelineRun or
            self.relatedDataProduct or
            self.parset
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LTASip'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sipGeneratorVersion is not None:
            showIndent(outfile, level)
            outfile.write('sipGeneratorVersion=%s,\n' % quote_python(self.sipGeneratorVersion).encode(ExternalEncoding))
        if self.project is not None:
            showIndent(outfile, level)
            outfile.write('project=model_.Project(\n')
            self.project.exportLiteral(outfile, level, name_='project')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataProduct is not None:
            showIndent(outfile, level)
            outfile.write('dataProduct=model_.DataProduct(\n')
            self.dataProduct.exportLiteral(outfile, level, name_='dataProduct')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('observation=[\n')
        level += 1
        for observation_ in self.observation:
            showIndent(outfile, level)
            outfile.write('model_.Observation(\n')
            observation_.exportLiteral(outfile, level, name_='Observation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pipelineRun=[\n')
        level += 1
        for pipelineRun_ in self.pipelineRun:
            showIndent(outfile, level)
            outfile.write('model_.PipelineRun(\n')
            pipelineRun_.exportLiteral(outfile, level, name_='PipelineRun')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('relatedDataProduct=[\n')
        level += 1
        for relatedDataProduct_ in self.relatedDataProduct:
            showIndent(outfile, level)
            outfile.write('model_.DataProduct(\n')
            relatedDataProduct_.exportLiteral(outfile, level, name_='DataProduct')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('parset=[\n')
        level += 1
        for parset_ in self.parset:
            showIndent(outfile, level)
            outfile.write('model_.Parset(\n')
            parset_.exportLiteral(outfile, level, name_='Parset')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sipGeneratorVersion':
            sipGeneratorVersion_ = child_.text
            sipGeneratorVersion_ = self.gds_validate_string(sipGeneratorVersion_, node, 'sipGeneratorVersion')
            self.sipGeneratorVersion = sipGeneratorVersion_
        elif nodeName_ == 'project':
            obj_ = Project.factory()
            obj_.build(child_)
            self.set_project(obj_)
        elif nodeName_ == 'dataProduct':
            class_obj_ = self.get_class_obj_(child_, DataProduct)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_dataProduct(obj_)
        elif nodeName_ == 'observation':
            obj_ = Observation.factory()
            obj_.build(child_)
            self.observation.append(obj_)
        elif nodeName_ == 'pipelineRun':
            class_obj_ = self.get_class_obj_(child_, PipelineRun)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.pipelineRun.append(obj_)
        elif nodeName_ == 'relatedDataProduct':
            class_obj_ = self.get_class_obj_(child_, DataProduct)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.relatedDataProduct.append(obj_)
        elif nodeName_ == 'parset':
            obj_ = Parset.factory()
            obj_.build(child_)
            self.parset.append(obj_)
# end class LTASip


GDSClassesMapping = {
    'dataProductIdentifier': IdentifierType,
    'coordinate': Coordinate,
    'pointing': Pointing,
    'observationProcessIdentifier': IdentifierType,
    'offset': Pointing,
    'timeLinearAxis': LinearAxis,
    'parset': Parset,
    'polarizationTabularAxis': TabularAxis,
    'samplingTime': Time,
    'centralFrequencies': ListOfFrequencies,
    'restoringBeamMinor': Angle,
    'radius': Length,
    'rightAscension': Angle,
    'directionLinearAxis': LinearAxis,
    'correlator': Correlator,
    'rawSamplingTime': Time,
    'spectralQuantity': SpectralQuantity,
    'observationId': IdentifierType,
    'channelWidth': Frequency,
    'clock': ClockType,
    'rmsNoise': Pixel,
    'altitude': Angle,
    'timeTabularAxis': TabularAxis,
    'subArrayPointings': SubArrayPointings,
    'restoringBeamMajor': Angle,
    'station': Station,
    'location': Coordinates,
    'beams': ArrayBeams,
    'imagerIntegrationTime': Time,
    'latitude': Angle,
    'relatedDataProduct': DataProduct,
    'declination': Angle,
    'pipelineRun': PipelineRun,
    'spectralTabularAxis': TabularAxis,
    'transientBufferBoardEvents': TransientBufferBoardEvents,
    'latitudePole': Angle,
    'processing': Processing,
    'ltaSip': LTASip,
    'transientBufferBoardEvent': TransientBufferBoardEvent,
    'subArrayPointingIdentifier': IdentifierType,
    'spectralLinearAxis': LinearAxis,
    'processIdentifier': IdentifierType,
    'dataProduct': DataProduct,
    'coherentStokes': CoherentStokes,
    'incoherentStokes': IncoherentStokes,
    'integrationInterval': Time,
    'identifier': IdentifierType,
    'observation': Observation,
    'sourceData': DataSources,
    'stations': Stations,
    'checksum': ChecksumType,
    'centralFrequency': Frequency,
    'longitudePole': Angle,
    'subArrayPointing': SubArrayPointing,
    'longitude': Angle,
    'nonStandard': NonStandard,
    'project': Project,
    'triggerParameters': TBBTrigger,
    'antennaField': AntennaField,
    'beam': ArrayBeam,
    'azimuth': Angle,
    'y': Length,
    'x': Length,
    'z': Length,
    'observationPointing': Pointing,
    'flysEye': FlysEye,
    'arrayBeam': ArrayBeam,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Frequency'
        rootClass = Frequency
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag,
##         namespacedef_='',
##         pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Frequency'
        rootClass = Frequency
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="Frequency",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Frequency'
        rootClass = Frequency
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from sipapi import *\n\n')
##     sys.stdout.write('from datetime import datetime as datetime_\n\n')
##     sys.stdout.write('import sipapi as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Angle",
    "AntennaField",
    "ArrayBeam",
    "ArrayBeams",
    "AveragingPipeline",
    "Axis",
    "BeamFormedDataProduct",
    "CalibrationPipeline",
    "ChecksumType",
    "ClockType",
    "CoherentStokes",
    "CoherentStokesBeam",
    "Coordinate",
    "Coordinates",
    "CorrelatedDataProduct",
    "Correlator",
    "CosmicRayPipeline",
    "DataProduct",
    "DataSources",
    "DirectDataMeasurement",
    "DirectionCoordinate",
    "FlysEye",
    "FlysEyeBeam",
    "Frequency",
    "GenericDataProduct",
    "GenericMeasurement",
    "GenericPipeline",
    "IdentifierType",
    "ImagingPipeline",
    "IncoherentStokes",
    "IncoherentStokesBeam",
    "InstrumentModelDataProduct",
    "KnownPulsarPipeline",
    "LTASip",
    "Length",
    "LinearAxis",
    "ListOfFrequencies",
    "NonStandard",
    "Observation",
    "Parset",
    "PipelineRun",
    "Pixel",
    "PixelMapDataProduct",
    "Pointing",
    "PolarizationCoordinate",
    "Process",
    "Processing",
    "Project",
    "PulpDataProduct",
    "PulsarSearchPipeline",
    "RealTimeProcess",
    "SkyImageDataProduct",
    "SkyModelDataProduct",
    "SpectralCoordinate",
    "SpectralQuantity",
    "Station",
    "Stations",
    "SubArrayPointing",
    "SubArrayPointings",
    "TBBTrigger",
    "TabularAxis",
    "Time",
    "TimeCoordinate",
    "TransientBufferBoardDataProduct",
    "TransientBufferBoardEvent",
    "TransientBufferBoardEvents",
    "UnspecifiedDataProduct",
    "UnspecifiedProcess",
    "coordinateSystem"
    ]
